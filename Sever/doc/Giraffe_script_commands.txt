//===== Giraffe 模擬器 - 文檔 ====================
//= 管理員指令 (AtCommand) 說明文檔
//===== 文檔描述 =============================================
//= 此文檔對 Giraffe 模擬器添加的 GM 指令進行功能說明以及介紹.
//============================================================

*setheaddir <朝向編號>{,<角色編號>};

調整角色紙娃娃腦袋的朝向

朝向編號:
	0 = 相對於身體朝向的正前方, 頭部看向正前方
	1 = 相對於身體朝向的正前方, 頭部看向右看
	2 = 相對於身體朝向的正前方, 頭部看向左看

角色編號:
	可選參數, 若不攜帶此參數則控制當前腳本關聯的角色
	若填寫了指定角色編號, 那麽就控制指定角色

返回值:
	該指令無論執行成功與否, 都不會有返回值

--------------------------------------------------------------

*setbodydir <朝向編號>{,<角色編號>};

調整角色紙娃娃身體的朝向

朝向編號:
    1 = 西北      0 = 正北      7 = 東北
              ↖     |     ↗
    2 = 正西  <-     +     ->   6 = 正東
              ↙     |     ↘
    3 = 西南      4 = 正南      5 = 東南

角色編號:
	可選參數, 若不攜帶此參數則控制當前腳本關聯的角色
	若填寫了指定角色編號, 那麽就控制指定角色

返回值:
	該指令無論執行成功與否, 都不會有返回值

--------------------------------------------------------------

*openbank {<角色編號>};

讓指定的角色立刻打開銀行界面 (只對擁有隨身銀行的客戶端版本有效).

角色編號:
	可選參數, 若不攜帶此參數則控制當前腳本關聯的角色
	若填寫了指定角色編號, 那麽就控制指定角色

返回值:
	若打開銀行失敗則返回 0, 成功則返回 1

--------------------------------------------------------------

*instance_users <副本實例編號>;

獲取指定的副本實例中已經進入副本地圖的人數

副本實例編號:
	必填項, 這里填寫的副本編號就是 instance_create 腳本指令返回的那個數值

舉例說明:
	可以用 instance_id 腳本指令來獲得當前隊伍關聯的副本實例編號
	
	.@party_instance_id = instance_id(IM_PARTY);
	if (.@party_instance_id == 0) {
		dispbottom "你的隊伍當前並沒有創建副本.";
	}
	dispbottom "副本地圖中當前人數: " + instance_users(.@party_instance_id) + " 人";

返回值:
	成功直接返回副本中的人數, 副本不存在或副本中無人存在則返回 0

--------------------------------------------------------------

*cap <要判斷的數值>,<最小值>,<最大值>;

確保數值不低於給定的最小值, 不超過給定的最大值

要判斷的數值:
	必填項, 數值類型的值

最小值:
	必填項, 數值類型的值

最大值:
	必填項, 數值類型的值

不推薦使用:
	rAthena 已經推出了功能完全一致的指令 cap_value;
	建議優先使用 rAthena 官方指令, 以便確保最大的腳本兼容性.
	此處的 cap 實際上是 cap_value 的別名, 以便兼容以前的部分腳本.

返回值:
	要判斷的數值低於最小值則直接返回最小值, 超過最大值則直接返回最大值,
	如果要判斷的數值在兩者之間, 那麽原樣返回該數值

--------------------------------------------------------------

*mobremove <魔物的GID>;

根據 GID 移除一個魔物(只是移除, 不會讓魔物死亡)

魔物的GID:
	必填項, 比如使用 monster 腳本指令後 $@mobid[] 數組的內容

返回值:
	該指令無論執行成功與否, 都不會有返回值
	
--------------------------------------------------------------

*mesclear;

清空玩家與當前 NPC 的對話框內容, 清空後可以用 mes 重新給對話框填充內容

不推薦使用:
	rAthena 已經推出了功能完全一致的指令 clear;
	建議優先使用 rAthena 官方指令, 以便確保最大的腳本兼容性.
	此處的 mesclear 實際上是 clear 的別名, 以便兼容以前的部分腳本.

返回值:
	該指令無論執行成功與否, 都不會有返回值

--------------------------------------------------------------

*battleignore <開關標記>{,<角色編號>};

將指定的角色設置為魔物免戰狀態, 避免被魔物攻擊
魔物會無視此玩家的存在, 因此不會攻擊該玩家 (也可以叫無敵狀態)

不推薦使用:
	rAthena 已經推出了類似的腳本指令解決方案.
	啟用無敵狀態等價於 rAthena 的官方指令用法: setpcblock PCBLOCK_IMMUNE, 1;
	建議優先使用 rAthena 官方指令, 以便確保最大的腳本兼容性.

開關標記:
	0 - 關閉免戰 (角色會被魔物看見)
	1 - 打開免戰 (角色不會被魔物看見, 也不會被攻擊)

返回值:
	該指令無論執行成功與否, 都不會有返回值

--------------------------------------------------------------

*getinventorylist {<角色編號>{,<想查詢的數據類型>}};

用於查詢玩家背包中的物品列表以及物品的全部詳情信息, 該指令在 rAthena 的基礎上得到了改進.

想查詢的數據類型:
	有的用戶會把玩家的背包擴充到一個比較大的值, 這時候如果還有一個腳本頻繁調用 getinventorylist 的話,
	會導致程序默認填充幾乎所有物品信息回來, 而往往很多信息我們用不到, 這就會出現多余的性能開銷.

	你可以通過該掩碼參數來控制指令內部給你填充指定的一個或多個數組, 降低程序填充數據的工作量來降低卡頓.

	INV_ID              = 填充 @inventorylist_id[]                  - 道具編號
	INV_IDX             = 填充 @inventorylist_idx[]                 - 道具的背包序號
	INV_AMOUNT          = 填充 @inventorylist_amount[]              - 道具的數量
	INV_EQUIP           = 填充 @inventorylist_equip[]               - 道具當前的裝備位置
	INV_REFINE          = 填充 @inventorylist_refine[]              - 道具的精煉值
	INV_IDENTIFY        = 填充 @inventorylist_identify[]            - 道具是否已鑒定 (0: 未鑒定; 1: 已鑒定)
	INV_ATTRIBUTE       = 填充 @inventorylist_attribute[]           - 道具的屬性

	INV_CARD            = 填充物品的插卡信息數組:
	                      @inventorylist_card1[]                   - 道具一號卡槽的卡片編號
	                      @inventorylist_card2[]                   - 道具二號卡槽的卡片編號
	                      @inventorylist_card3[]                   - 道具三號卡槽的卡片編號
	                      @inventorylist_card4[]                   - 道具四號卡槽的卡片編號

	INV_EXPIRE          = 填充 @inventorylist_expire[]              - 道具的過期時間戳 (0: 永不過期; 其他非零正整數表示 Unix 時間戳)
	INV_BOUND           = 填充 @inventorylist_bound[]               - 道具的綁定狀態
	INV_ENCHANTGRADE    = 填充 @inventorylist_enchantgrade[]        - 道具的附魔評級

	INV_OPTION          = 填充物品隨機屬性(Random Option)的信息數組:
	                      @inventorylist_option_id1[]
	                      @inventorylist_option_value1[]
	                      @inventorylist_option_parameter1[]
	                      @inventorylist_option_id2[]
	                      @inventorylist_option_value2[]
	                      @inventorylist_option_parameter2[]
	                      @inventorylist_option_id3[]
	                      @inventorylist_option_value3[]
	                      @inventorylist_option_parameter3[]
	                      @inventorylist_option_id4[]
	                      @inventorylist_option_value4[]
	                      @inventorylist_option_parameter4[]
	                      @inventorylist_option_id5[]
	                      @inventorylist_option_value5[]
	                      @inventorylist_option_parameter5[]

	INV_TRADABLE        = 填充 @inventorylist_tradable[]           - 道具是否可交易
	INV_FAVORITE        = 填充 @inventorylist_favorite[]           - 道具是否被標記為最喜歡的道具 (0: 未標記; 1: 已標記)
	INV_UID             = 填充 @inventorylist_uid$[]               - 道具的唯一編號 (字符串類型的數組, 末尾記得要帶 $ 符號)
	INV_EQUIPSWITCH     = 填充 @inventorylist_equipswitch[]        - 道具作為第二套快速切換裝備時的穿戴位置
	INV_ALL             = 填充以上全部數組(默認值)

舉例說明:
	想查詢背包中所有道具的信息, 但只希望獲取背包序號和數量:
	getinventorylist(getcharid(0), INV_IDX | INV_AMOUNT);

注意事項:
	若你指定了需要查詢的數據類型, 那麽未被查詢的數據數組將不會被填充.

背包序號:
	背包序號每一次登錄、每一次玩家在自己的背包中增刪物品 (包括但不限: 
	存倉、存手推車、丟棄、購買和使用道具等操作) 都可能會導致背包序號有變化.
	所以請注意在一段連續、玩家不可能會停下來做其他動作的腳本中去使用“背包序號”.
	否則, 只要在 getinventorylist 之後, 還給玩家或腳本去進行道具的增刪,
	那麽 @inventorylist_idx[] 中的數據將立刻變得不再可靠.

--------------------------------------------------------------

*getcartlist {<角色編號>{,<想查詢的數據>}};

與 getinventorylist 類似, 但是查詢的是玩家的手推車中的物品信息.
它的返回數組與 getinventorylist 完全一致, 只是部分數組的意義會發生變化:

- @inventorylist_favorite[]     - 該數組無意義並且值固定為 0,
                                  因為手推車中的道具不能被標記為最喜歡的道具.
- @inventorylist_equipswitch[]  - 該數組無意義並且值固定為 0,
                                  因為手推車中的道具不能被作為第二套快速切換裝備.
- @inventorylist_idx[]          - 道具的手推車序號

特別注意:
	這里 @inventorylist_idx[] 讀取到的序號不再是道具的背包序號,
	應該使用 getcartinfo 而不是 getinventoryinfo 來獲取物品的詳細信息.
	
	玩家必須擁有手推車才能調用該指令, 否則會拋出錯誤.
	
	若想規避終端提示無手推車錯誤, 
	可以在調用該指令之前使用 checkcart() 來確保玩家有手推車.

--------------------------------------------------------------

*getguildstoragelist {<角色編號>{,<想查詢的數據>}};

與 getinventorylist 類似, 但是查詢的是公會倉庫中的物品信息.
它的返回數組與 getinventorylist 完全一致, 只是部分數組的意義會發生變化:

- @inventorylist_favorite[]     - 該數組無意義並且值固定為 0,
                                  因為公會倉庫中的道具不能被標記為最喜歡的道具.
- @inventorylist_equipswitch[]  - 該數組無意義並且值固定為 0,
                                  因為公會倉庫中的道具不能被作為第二套快速切換裝備.
- @inventorylist_idx[]          - 道具的公會倉庫序號

特別注意:
	這里 @inventorylist_idx[] 讀取到的序號不再是道具的背包序號,
	應該使用 getguildstorageinfo 而不是 getinventoryinfo 來獲取物品的詳細信息.
	
	玩家必須加入擁有公會倉庫的公會才能調用該指令, 否則會拋出錯誤.
	
	若想規避終端提示未加入公會以及沒有公會倉庫的錯誤,
	可以在調用該指令之前使用 getgdskilllv(getcharid(2), "GD_GUILD_STORAGE") > 0
	來確保玩家已加入有公會倉庫的公會.

--------------------------------------------------------------

*getstoragelist {<角色編號>{,<想查詢的數據>{,<倉庫編號>}}};

與 getinventorylist 類似, 但是查詢的是個人倉庫/擴充倉庫中的物品信息.
它的返回數組與 getinventorylist 完全一致, 只是部分數組的意義會發生變化:

- @inventorylist_favorite[]     - 該數組無意義並且值固定為 0,
                                  因為個人倉庫/擴充倉庫中的道具不能被標記為最喜歡的道具.
- @inventorylist_equipswitch[]  - 該數組無意義並且值固定為 0,
                                  因為個人倉庫/擴充倉庫中的道具不能被作為第二套快速切換裝備.
- @inventorylist_idx[]          - 道具的個人倉庫/擴充倉庫序號

特別注意:
	這里 @inventorylist_idx[] 讀取到的序號不再是道具的背包序號,
	應該使用 getstorageinfo 而不是 getinventoryinfo 來獲取物品的詳細信息.

倉庫編號:
	該指令支持獲取擴充倉庫的內容, 因此你需要在查詢時指定倉庫編號.

	0 - 個人倉庫 (每個玩家都會有的默認倉庫)
	X - 擴充倉庫 (其他非 0 的定義在 conf/inter_athena.yml 中的有效倉庫編號)

注意事項:
	該指令的參數順序和 getinventorylist、getcartlist、
	getguildstoragelist 有所差異, 使用的時候一定要注意, 不要被坑了.

--------------------------------------------------------------

*readparam(<參數代碼>{,"<角色名稱>"})
*readparam(<參數代碼>{,<角色編號>})

在 rAthena 原來的參數代碼基礎上, Giraffe<模擬器>新增了以下幾個參數:

bAllStr - 返回角色的總 STR (用總 STR 減去 bStr 可得到面板中 STR 在加號右側的值)
bAllAgi - 返回角色的總 AGI (用總 AGI 減去 bAgi 可得到面板中 AGI 在加號右側的值)
bAllVit - 返回角色的總 VIT (用總 VIT 減去 bVit 可得到面板中 VIT 在加號右側的值)
bAllInt - 返回角色的總 INT (用總 INT 減去 bInt 可得到面板中 INT 在加號右側的值)
bAllDex - 返回角色的總 DEX (用總 DEX 減去 bDex 可得到面板中 DEX 在加號右側的值)
bAllLuk - 返回角色的總 LUK (用總 LUK 減去 bLuk 可得到面板中 LUK 在加號右側的值)

bAllPow - 返回角色的總 Pow (用總 Pow 減去 bPow 可得到面板中 Pow 在加號右側的值)
bAllSta - 返回角色的總 STA (用總 AGI 減去 bSta 可得到面板中 STA 在加號右側的值)
bAllWis - 返回角色的總 WIS (用總 VIT 減去 bWis 可得到面板中 WIS 在加號右側的值)
bAllSpl - 返回角色的總 SPL (用總 INT 減去 bSpl 可得到面板中 SPL 在加號右側的值)
bAllCon - 返回角色的總 CON (用總 DEX 減去 bCon 可得到面板中 CON 在加號右側的值)
bAllCrt - 返回角色的總 CRT (用總 LUK 減去 bCrt 可得到面板中 CRT 在加號右側的值)

CartWeight - 手推車中的物品總重量 (脫下手推車時數值為 0)
MaxCartWeight - 手推車的最大負重量 (脫下手推車時數值為 0)

使用方法:
	dispbottom "總STR為 : " + readparam(bAllStr) + " (" + readparam(bStr) + " + " + (readparam(bAllStr) - readparam(bStr)) + ")";
	dispbottom "總POW為 : " + readparam(bAllPow) + " (" + readparam(bPow) + " + " + (readparam(bAllPow) - readparam(bPow)) + ")";
	dispbottom "手推車當前負重情況: " + CartWeight + "/" + MaxCartWeight;
提示信息:
	被 readparam 調用的有效 <參數代碼> 可以直接當做常量使用

--------------------------------------------------------------

*gethotkey <快捷鍵位置編號>{,<要獲取的數據類型>};
*get_hotkey <快捷鍵位置編號>{,<要獲取的數據類型>};

獲取指定快捷鍵位置的信息, 快捷鍵位置編號必須大於 0 小於 MAX_HOTKEYS.
MAX_HOTKEYS 是個常量, 在腳本中可以直接使用以下方法來確認它的值:

	dispbottom "MAX_HOTKEYS = " + MAX_HOTKEYS;

要獲取的數據類型:
	可選參數, 若攜帶這個參數則函數的返回值會具備不同含義:
	0	- 獲取快捷鍵的類型
		> 若返回 0 表示該位置的快捷鍵上放的是一個物品
		> 若返回 1 表示該位置的快捷鍵上放的是一個技能
	1	- 獲取技能編號或物品編號
	2	- 獲取登記在快捷鍵上的技能等級

	若不攜帶 <要獲取的數據類型> 參數, 那麽指定的快捷鍵的信息會被存放到以下角色變量:
	
	@hotkey_type	- 快捷鍵的類型 (為 0 表示物品, 為 1 表示技能)
	@hotkey_id		- 技能編號或物品編號
	@hotkey_lv		- 登記在快捷鍵上的技能等級

返回值:
	若攜帶 <要獲取的數據類型> 參數時, 發生錯誤將返回 -1, 成功則返回查詢的值;
	不攜帶 <要獲取的數據類型> 參數時, 發生錯誤將返回 -1, 成功則將信息保存到變量並返回 1

--------------------------------------------------------------

*sethotkey <快捷鍵位置編號>,<快捷鍵的類型>,<物品編號/技能編號>,<技能等級>;
*set_hotkey <快捷鍵位置編號>,<快捷鍵的類型>,<物品編號/技能編號>,<技能等級>;

設置玩家快捷鍵工具欄上的內容, 快捷鍵位置編號必須大於 0 小於 MAX_HOTKEYS.
MAX_HOTKEYS 是個常量, 在腳本中可以直接使用以下方法來確認它的值:

	dispbottom "MAX_HOTKEYS = " + MAX_HOTKEYS;

快捷鍵的類型:
	0	- 這個快捷鍵想放置一個物品 (若使用該值, 則"技能等級"參數無意義, 請直接給"技能等級"參數傳 0 即可)
	1	- 這個快捷鍵想放置一個技能

物品編號/技能編號:
	根據您 <快捷鍵的類型> 的取值不同而擁有不同含義, 程序會校驗給定的物品編號或技能編號是否有效.

技能等級:
	只有當 <快捷鍵的類型> 的值為 1 時才有意義. 若是個物品的話, 這里隨便傳什麽都會被默認為 0.

返回值:
	設置成功則返回 1, 設置失敗則返回 0

--------------------------------------------------------------

*showvend "<NPC名稱>",<是否顯示>{,"<招牌名稱>"};

使指定的 NPC 頭上可以顯示露天商店的招牌, 點擊招牌可觸發與 NPC 的對話.

NPC名稱:
	你可以指定 NPC 的名稱, 或者用 strnpcinfo(0) 獲取當前 NPC 的名稱.

是否顯示:
	0 - 隱藏招牌 (當選擇隱藏招牌時, <招牌名稱> 參數可不傳遞)
	1 - 顯示招牌

返回值:
	操作成功則返回 1, 操作失敗則返回 0

--------------------------------------------------------------

*viewequip <目標的角色編號|目標的賬號編號>{,<是否強制查看>};

查看指定在線角色的裝備面板信息.

是否強制查看:
	0	- 若目標角色禁止其他玩家查看裝備, 那麽就不查看 (對 GM 無影響)
	1	- 無視目標角色設置, 強制進行查看

返回值:
	操作成功則返回 1, 操作失敗則返回 0

--------------------------------------------------------------

*countitemidx <背包序號>{,<角色編號>};
*countinventory <背包序號>{,<角色編號>};

獲取指定背包序號的道具在背包中的數量. 

背包序號:
	可以通過 getinventorylist 腳本指令的 @inventorylist_idx[] 數組來獲得.

返回值:
	操作成功則返回道具的數量, 操作失敗則返回 0

--------------------------------------------------------------

*delitemidx <背包序號>{,<移除的數量>{,<角色編號>}};
*delinventory <背包序號>{,<移除的數量>{,<角色編號>}};

移除指定背包序號的道具, 支持指定移除數量以及目標角色編號. 
若被指定的道具已穿戴在目標角色身上, 那麽該裝備會被立刻脫下並移除.

背包序號:
	可以通過 getinventorylist 腳本指令的 @inventorylist_idx[] 數組來獲得.

移除的數量:
	可選參數, 若不指定, 則表示你想刪除指定道具的全部.

返回值:
	操作成功則返回 1, 操作失敗則返回 0

--------------------------------------------------------------

*identifyidx <背包序號>{,<角色編號>};
*identifybyidx <背包序號>{,<角色編號>};

鑒定指定背包序號的道具.
只要背包序號合法, 哪怕道具已經被鑒定過, 該函數也會返回 1.

背包序號:
	可以通過 getinventorylist 腳本指令的 @inventorylist_idx[] 數組來獲得.

返回值:
	操作成功則返回 1, 操作失敗則返回 0

--------------------------------------------------------------

*unequipidx <背包序號>{,<角色編號>};
*unequipinventory <背包序號>{,<角色編號>};

脫下指定背包序號的道具.
只要背包序號合法, 哪怕道具已被脫下, 該函數也會返回 1.
若指定的道具不是裝備, 那麽該函數將返回 0 (但不會報錯, 也不會警告).

背包序號:
	可以通過 getinventorylist 腳本指令的 @inventorylist_idx[] 數組來獲得.

返回值:
	操作成功則返回 1, 操作失敗則返回 0

--------------------------------------------------------------

*equipidx <背包序號>{,<角色編號>};
*equipinventory <背包序號>{,<角色編號>};

穿戴指定背包序號的道具.
只要背包序號合法, 哪怕道具已被穿戴, 該函數也會返回 1.
若指定的道具不是裝備, 那麽該函數將返回 0 (但不會報錯, 也不會警告).

背包序號:
	可以通過 getinventorylist 腳本指令的 @inventorylist_idx[] 數組來獲得.

返回值:
	操作成功則返回 1, 操作失敗則返回 0


--------------------------------------------------------------

*itemexists <物品編號/"物品名稱">;
*existitem <物品編號/"物品名稱">;

確認物品數據庫中是否存在指定物品, 通常用於提高腳本的健壯性.

物品編號/"物品名稱":
	多類型參數. 可以填寫數值類型的道具編號, 或者字符串類型的道具名稱.
	推薦使用道具編號, 相較而言結果會更加準確.

注意事項:
	查詢時請避免填寫 [字符串類型] 的道具編號, 
	因為這里的參數只要是字符串類型的, 都會走物品名稱判斷邏輯.

返回值:
	若物品指定的道具編號不存在於數據庫中則返回 0,
	若物品存在且 [可堆疊] 則返回 [正數] 物品編號, [不可堆疊] 則返回 [負數] 物品編號

--------------------------------------------------------------

*renttime <EQI裝備位置>,<增減的時間秒數>{,<角色編號>};
*setrenttime <EQI裝備位置>,<增減的時間秒數>{,<角色編號>};
*resume <EQI裝備位置>,<增減的時間秒數>{,<角色編號>};

增加/減少指定位置裝備的租賃時間.
如果要減少租賃時間的話, 第二個參數請使用負數.

EQI裝備位置:
	是指 EQI_* 開頭的位置常量, 可參考 doc/script_commands.txt

增減的時間秒數:
	若需要減少時間的話, 請使用負數.

注意事項:
	input 指令會將所有小於 0 的用戶輸入數值變成 0.
	若您希望由玩家通過 input 指令來指定要減少的秒數, 那麽需要加個負數符號.
	或者修改 conf/script_athena.conf 中 input_min_value 選項的值.

返回值:
	操作失敗返回 0, 非 0 的正數表示成功增減後新的剩余時間秒數
	若指定位置沒有穿戴裝備, 或指定位置的裝備並非租賃道具, 函數都會返回 0

--------------------------------------------------------------

*getequipidx <EQI裝備位置>{,<角色編號>};

獲取指定位置裝備的背包序號. 注意該函數返回 0 不代表失敗.

EQI裝備位置:
	EQI_COMPOUND_ON (-1)      - Item slot that calls this script (In context of item script)
	EQI_ACC_L (0)             - Accessory 1
	EQI_ACC_R (1)             - Accessory 2
	EQI_SHOES (2)             - Footgear (shoes, boots)
	EQI_GARMENT (3)           - Garment (mufflers, hoods, manteaux)
	EQI_HEAD_LOW (4)          - Lower Headgear (beards, some masks)
	EQI_HEAD_MID (5)          - Middle Headgear (masks, glasses)
	EQI_HEAD_TOP (6)          - Upper Headgear
	EQI_ARMOR (7)             - Armor (jackets, robes)
	EQI_HAND_L (8)            - Left hand (weapons, shields)
	EQI_HAND_R (9)            - Right hand (weapons)
	EQI_COSTUME_HEAD_TOP (10) - Upper Costume Headgear
	EQI_COSTUME_HEAD_MID (11) - Middle Costume Headgear
	EQI_COSTUME_HEAD_LOW (12) - Lower Costume Headgear
	EQI_COSTUME_GARMENT (13)  - Costume Garment
	EQI_AMMO (14)    		  - Arrow/Ammunition
	EQI_SHADOW_ARMOR (15)     - Shadow Armor
	EQI_SHADOW_WEAPON (16)    - Shadow Weapon
	EQI_SHADOW_SHIELD (17)    - Shadow Shield
	EQI_SHADOW_SHOES (18)     - Shadow Shoes
	EQI_SHADOW_ACC_R (19)     - Shadow Accessory 2
	EQI_SHADOW_ACC_L (20)     - Shadow Accessory 1


返回值:
	-1 - 在指定的EQI裝備位置找不到裝備
	-2 - 填寫的EQI裝備位置無效
	-3 - 指定的角色編號無效, 或者目標玩家不在線
	其他大於等於 0 的數值則表示成功, 返回值就是所查位置裝備的背包序號

--------------------------------------------------------------

*statuscalc;
*status_calc;

根據角色目前的裝備、技能、狀態以及其他各種加成, 重新執行計算玩家的能力.

不推薦使用:
	rAthena 已經推出了功能完全一致的指令 recalculatestat;
	建議優先使用 rAthena 官方指令, 以便確保最大的腳本兼容性.
	此處的 statuscalc 和 status_calc 實際上是 recalculatestat 的別名, 以便兼容以前的部分腳本.

返回值:
	該指令無論執行成功與否, 都不會有返回值

--------------------------------------------------------------

*getequipexpiretick <EQI裝備位置>{,<角色編號>};
*isrental <EQI裝備位置>{,<角色編號>};

獲取指定位置裝備的租賃到期剩余秒數.

EQI裝備位置:
	是指 EQI_* 開頭的位置常量, 可參考 doc/script_commands.txt

返回值:
	-1 - 在指定的EQI裝備位置找不到裝備
	-2 - 填寫的EQI裝備位置無效
	-3 - 指定的角色編號無效, 或者目標玩家不在線
	-4 - 剩余秒數不合法 (比如: 道具早應該過期消失了, 但居然還在背包里)
	 0 - 此裝備不是租賃裝備, 永久有效
	其他大於 0 的數值則代表租賃到期的剩余秒數

--------------------------------------------------------------

*updateinventory {<角色編號>};

該指令用於重新下發關聯玩家的背包數據給客戶端.
涵蓋角色背包每一個道具的每一個信息, 請避免高頻調用或者循環調用.

--------------------------------------------------------------

*getinventoryinfo <道具的背包序號>,<要查看的信息類型>{,<角色編號>};

查詢指定背包序號的道具詳細信息.

道具的背包序號:
	可以通過 getinventorylist 腳本指令的 @inventorylist_idx[] 數組來獲得.

要查看的信息類型:
	0   - 物品編號
	1   - 堆疊數量
	2   - 裝備的穿戴位置
	3   - 精煉值
	4   - 是否已鑒定 (若已鑒定則返回 1, 未鑒定則返回 0)
	5   - 是否已損壞 (若已損壞則返回 1, 未損壞則返回 0)
	6   - 第一個卡槽的卡片編號
	7   - 第二個卡槽的卡片編號
	8   - 第三個卡槽的卡片編號
	9   - 第四個卡槽的卡片編號
	10  - 過期時間 (Unix時間戳, 0 表示永不過期)
	11  - 唯一編號 (unique_id)
	
	12  - 第一個隨機屬性的編號 (ROA_ID)
	13  - 第二個隨機屬性的編號 (ROA_ID)
	14  - 第三個隨機屬性的編號 (ROA_ID)
	15  - 第四個隨機屬性的編號 (ROA_ID)
	16  - 第五個隨機屬性的編號 (ROA_ID)
	
	17  - 第一個隨機屬性的值 (ROA_VALUE)
	18  - 第二個隨機屬性的值 (ROA_VALUE)
	19  - 第三個隨機屬性的值 (ROA_VALUE)
	20  - 第四個隨機屬性的值 (ROA_VALUE)
	21  - 第五個隨機屬性的值 (ROA_VALUE)
	
	22  - 第一個隨機屬性的參數 (ROA_PARAM)
	23  - 第二個隨機屬性的參數 (ROA_PARAM)
	24  - 第三個隨機屬性的參數 (ROA_PARAM)
	25  - 第四個隨機屬性的參數 (ROA_PARAM)
	26  - 第五個隨機屬性的參數 (ROA_PARAM)

	27  - 道具的綁定類型
	28  - 道具的附魔評級 (Grade Level)
	29  - 道具作為第二套快速切換裝備時的穿戴位置
	30  - 道具是否被標記為最喜歡的道具 (0: 未標記; 1: 已標記)

裝備的穿戴位置:
	如果為 0 則表示還沒穿戴在身上, 位置請參考 EQP_* 開頭的常量
	查詢的信息類型 2 和 29 都是 EQP_* 開頭的常量.

道具的綁定類型:
	Bound_None      -   沒有綁定 (與 0 等價, 但更推薦用常量)
	Bound_Account   -   綁定賬號的道具, 可放個人倉庫, 全賬號共享
	Bound_Guild     -   綁定公會的道具, 可放公會倉庫與他人共享, 擁有物品的人離開公會後物品消失
	Bound_Party     -   綁定隊伍的道具, 離開隊伍後消失
	Bound_Char      -   綁定角色的道具, 不能放個人倉庫

注意事項:
	從 v1.0.6 版本開始,
	若查詢的信息類型是 11 (裝備的唯一編號),
	那麽返回值既可以存放在數值型變量, 也可以存放在字符串型變量.

返回值:
	獲取失敗則返回 -1, 獲取成功則返回你所查詢的信息

--------------------------------------------------------------

*getcartinfo <道具的手推車序號>,<要查看的信息類型>{,<角色編號>};

查詢指定手推車序號的道具詳細信息.

道具的手推車序號:
	可以通過 getcartlist 腳本指令的 @inventorylist_idx[] 數組來獲得.

要查看的信息類型:
	請參考 getinventoryinfo 的參數定義, 它們完全一致.
	
	以下信息類型, 對於手推車道具沒有意義:

		29 - 道具作為第二套快速切換裝備時的穿戴位置
		     因為手推車中的道具不能作為第二套快速切換裝備
		30 - 道具是否被標記為最喜歡的道具
		     因為手推車中的道具不能被標記為最喜歡的道具

返回值:
	獲取失敗則返回 -1, 獲取成功則返回你所查詢的信息

--------------------------------------------------------------

*getguildstorageinfo <道具的公會倉庫序號>,<要查看的信息類型>{,<角色編號>};

查詢指定公會倉庫序號的道具詳細信息.

道具的公會倉庫序號:
	可以通過 getguildstoragelist 腳本指令的 @inventorylist_idx[] 數組來獲得.

要查看的信息類型:
	請參考 getinventoryinfo 的參數定義, 它們完全一致.
	
	以下信息類型, 對於公會倉庫道具沒有意義:

		29 - 道具作為第二套快速切換裝備時的穿戴位置
		     因為公會倉庫中的道具不能作為第二套快速切換裝備
		30 - 道具是否被標記為最喜歡的道具
		     因為公會倉庫中的道具不能被標記為最喜歡的道具

返回值:
	獲取失敗則返回 -1, 獲取成功則返回你所查詢的信息

--------------------------------------------------------------

*getstorageinfo <道具的個人倉庫/擴充倉庫序號>,<要查看的信息類型>{{,<倉庫編號>},<角色編號>};

查詢指定個人倉庫/擴充倉庫序號的道具詳細信息.

道具的個人倉庫/擴充倉庫序號:
	可以通過 getstoragelist 腳本指令的 @inventorylist_idx[] 數組來獲得.

要查看的信息類型:
	請參考 getinventoryinfo 的參數定義, 它們完全一致.
	
	以下信息類型, 對於個人倉庫/擴充倉庫道具沒有意義:

		29 - 道具作為第二套快速切換裝備時的穿戴位置
		     因為個人倉庫/擴充倉庫中的道具不能作為第二套快速切換裝備
		30 - 道具是否被標記為最喜歡的道具
		     因為個人倉庫/擴充倉庫中的道具不能被標記為最喜歡的道具

倉庫編號:
	該指令支持獲取擴充倉庫的內容, 因此你需要在查詢時指定倉庫編號.

	0 - 個人倉庫 (每個玩家都會有的默認倉庫)
	X - 擴充倉庫 (其他非 0 的定義在 conf/inter_athena.yml 中的有效倉庫編號)

返回值:
	獲取失敗則返回 -1, 獲取成功則返回你所查詢的信息

--------------------------------------------------------------

*setinventoryinfo <道具的背包序號>,<要設置的信息類型>,<值>{{,<標記位>},<角色編號>};

設置指定背包序號道具的詳細信息.
值得注意的是, 這里修改的主要是每個玩家各有不同的那些道具的屬性信息,
例如: 道具插入的卡片, 道具的精煉值等等

道具的背包序號:
	可以通過 getinventorylist 腳本指令的 @inventorylist_idx[] 數組來獲得.

要設置的信息類型:
	3   - 精煉值
	4   - 是否已鑒定 (若已鑒定則返回 1, 未鑒定則返回 0)
	5   - 是否已損壞 (若已損壞則返回 1, 未損壞則返回 0)
	6   - 第一個卡槽的卡片編號
	7   - 第二個卡槽的卡片編號
	8   - 第三個卡槽的卡片編號
	9   - 第四個卡槽的卡片編號
	10  - 過期時間 (Unix時間戳, 0 表示永不過期)
	11  - 唯一編號 (unique_id)
	
	12  - 第一個隨機屬性編號 (ROA_ID)
	13  - 第二個隨機屬性編號 (ROA_ID)
	14  - 第三個隨機屬性編號 (ROA_ID)
	15  - 第四個隨機屬性編號 (ROA_ID)
	16  - 第五個隨機屬性編號 (ROA_ID)
	
	17  - 第一個隨機屬性的值 (ROA_VALUE)
	18  - 第二個隨機屬性的值 (ROA_VALUE)
	19  - 第三個隨機屬性的值 (ROA_VALUE)
	20  - 第四個隨機屬性的值 (ROA_VALUE)
	21  - 第五個隨機屬性的值 (ROA_VALUE)
	
	22  - 第一個隨機屬性的參數 (ROA_PARAM)
	23  - 第二個隨機屬性的參數 (ROA_PARAM)
	24  - 第三個隨機屬性的參數 (ROA_PARAM)
	25  - 第四個隨機屬性的參數 (ROA_PARAM)
	26  - 第五個隨機屬性的參數 (ROA_PARAM)

	27  - 道具的綁定類型
	28  - 道具的附魔評級 (Grade Level)
	29  - 道具作為第二套快速切換裝備時的穿戴位置
	30  - 道具是否被標記為最喜歡的道具 (0: 未標記; 1: 已標記)

卡片編號:
	若將卡片編號設置為 0 則視為刪除卡片.
	需要注意的是, 卡片將會被憑空移除, 不會留下任何日志記錄.

隨機屬性編號:
	此處的編號是 item_randomopt_db.yml 數據庫中的 VAR_* 開頭的常量,
	但需要注意的是從 yml 文件中獲得的常量需要添加 RDMOPT_ 前綴才是最後生效的最終常量名,
	例如: VAR_MAXHPAMOUNT 最終常量名是 RDMOPT_VAR_MAXHPAMOUNT.
	
	若將此處的編號設置為 0, 那麽將會同時清空對應的 ROA_VALUE 和 ROA_PARAM 選項的值.

道具的綁定類型:
	Bound_None      -   沒有綁定 (與 0 等價, 但更推薦用常量)
	Bound_Account   -   綁定賬號的道具, 可放個人倉庫, 全賬號共享
	Bound_Guild     -   綁定公會的道具, 可放公會倉庫與他人共享, 擁有物品的人離開公會後物品消失
	Bound_Party     -   綁定隊伍的道具, 離開隊伍後消失
	Bound_Char      -   綁定角色的道具, 不能放個人倉庫

過期時間:
	當您要設置的類型是 10 (過期時間)時, 一定要注意這是個Unix時間戳.
	
	若將值設為 60 秒, 那麽道具會因為已過期被立刻刪掉:
		setinventoryinfo(<背包序號>, 10, 60);	// 錯誤

	延長道具 60 秒有效期的正確寫法是:
		setinventoryinfo(<背包序號>, 10, gettimetick(2) + 60);	// 正確

標記位:
	每次調用該指令時會調用按需重算角色屬性, 且必定重新發送完整背包數據給客戶端
	但如果因為你需要循環處理背包中的全部道具, 那麽你有 100 個道具, 
	服務器就需要把 100 個道具信息下發 100 次給客戶端, 這是非常低效且不合理的.
	
	原則上盡量避免大量循環調用 setinventoryinfo 指令,
	但如果無法避免, 那麽可以考慮通過傳遞特殊標記位, 來在循環過程中抑制能力重算
	或者背包數據的刷新行為, 在循環結束後再觸發一次相關行為.
	
		&1 : 跳過角色能力重算
		&2 : 跳過全量刷新角色的背包數據
		&4 : 忽略卡片插入合理性的校驗 (插入的道具類型必須是卡片, 卡片位置和裝備位置符合)
		&8 : 插入卡片無需寫入 picklog 記錄 (憑空生成)
	
	若標記位設置為 0 則表示維持默認行為.
	
	--------
	
	提示信息: 
	
	- 使用 &1 標記位的循環結束後, 可以使用 recalculatestat(); 觸發角色能力重算
	- 使用 &2 標記位的循環結束後, 可以使用 updateinventory(); 重現發送最新背包數據給客戶端

返回值:
	-1 - 設置失敗, 插入的卡片不合法
	 0 - 設置失敗
	 1 - 設置成功

--------------------------------------------------------------

*statuscheck <狀態編號>{,<遊戲單位編號>};
*sc_check <狀態編號>{,<遊戲單位編號>};

該指令用於判斷狀態是否存在, 並取得相關的狀態參數.

不推薦使用:
	rAthena 已經推出了功能近似的指令 getstatus;
	建議優先使用 rAthena 官方指令, 以便確保最大的腳本兼容性.

狀態編號:
	每一個增益或者減益狀態都有一個編號, 腳本中一般用常量表示.
	比如負重超過 50% 的狀態編號是: SC_WEIGHT50
	這部分的常量定義可以在: src/map/status.hpp 中的 sc_type 定義中找到.

遊戲單位編號:
	這個編號有不同的叫法: GameID, GID, MapID 等
	每一個遊戲中的對象只要會顯示在地圖上的, 就會有一個自己的 <遊戲單位編號>
	遊戲玩家進入遊戲後, 它的 <賬號編號> 就是他角色的 <遊戲單位編號>

信息通過變量返回:
	當返回值為 1 的時候, 可以通過以下變量來讀取狀態的參數:

	@sc_val1		狀態的第 1 個參數值 (如果是技能對應的狀態的話, 往往這個參數都是技能等級)
	@sc_val2		狀態的第 2 個參數值
	@sc_val3		狀態的第 3 個參數值
	@sc_val4		狀態的第 4 個參數值
	@sc_tickleft	狀態的剩余時間 (單位為毫秒, 若為 -1 表示永久有效)

注意事項:
	從 v1.0.7 版本開始 @sc_tickleft 的上限已經[不會再被限制]到 2147483647 毫秒.

返回值:
	獲取成功則返回 1, 角色沒有該狀態則返回 0, 其他錯誤返回 -1

--------------------------------------------------------------

*renttimeidx <背包序號>,<增減的時間秒數>{,<角色編號>};

增加/減少指定背包序號道具的租賃時間.
如果要減少租賃時間的話, 第二個參數請使用負數.

該指令與 renttime 近似, 只是 renttime 操作的是某個已穿戴的裝備,
而 renttimeidx 指令可以通過背包序號來指定要調整的物品.

背包序號:
	可以通過 getinventorylist 腳本指令的 @inventorylist_idx[] 數組來獲得.

增減的時間秒數:
	若需要減少時間的話, 請使用負數.

注意事項:
	input 指令會將所有小於 0 的用戶輸入數值變成 0.
	若您希望由玩家通過 input 指令來指定要減少的秒數, 那麽需要加個負數符號.
	或者修改 conf/script_athena.conf 中 input_min_value 選項的值.

返回值:
	操作失敗返回 0, 非 0 的正數表示成功增減後新的剩余時間秒數
	若指定位置沒有穿戴裝備, 或指定位置的裝備並非租賃道具, 函數都會返回 0

--------------------------------------------------------------

*party_leave {<角色編號>};

使當前角色或指定角色退出隊伍.

不推薦使用:
	rAthena 已經推出了功能近似的指令 party_delmember;
	建議優先使用 rAthena 官方指令, 以便確保最大的腳本兼容性.

角色編號:
	若不指定角色編號, 那麽將會使執行該指令的玩家退出隊伍.

返回值:
	若指定的角色不在線或不在隊伍中則返回 0,
	若角色成功退出隊伍則返回 1

--------------------------------------------------------------

*script4each <"{腳本}">,<腳本執行範圍>{,<動態參數>...};
*script4eachmob <"{腳本}">,<腳本執行範圍>{,<動態參數>...};
*script4eachnpc <"{腳本}">,<腳本執行範圍>{,<動態參數>...};

對指定範圍的單位執行相同的一段腳本.
若使用 script4each 指令, 則執行 <腳本> 的玩家將會成為其默認關聯玩家.

腳本的執行範圍:
	0 - 全服單位								例: script4each "{<腳本>}",0;
	1 - 指定地圖上的全部單位					例: script4each "{<腳本>}",1,<"地圖名稱">;
	2 - 以地圖某個點為中心半徑距離內的單位		例: script4each "{<腳本>}",2,<"地圖名稱">,<中心坐標x>,<中心坐標y>,<範圍>;
	3 - 指定玩家所在的隊伍中的全部隊伍成員		例: script4each "{<腳本>}",3,<角色編號>;
	4 - 指定玩家所在的公會中的全部公會成員		例: script4each "{<腳本>}",4,<角色編號>;
	5 - 指定區域內的全部單位					例: script4each "{<腳本>}",5,<"地圖名稱">,<坐標x0>,<坐標y0>,<坐標x1>,<坐標y1>;
	6 - 指定隊伍中的全部隊伍成員				例: script4each "{<腳本>}",6,<隊伍編號>;
	7 - 指定公會中的全部公會成員				例: script4each "{<腳本>}",7,<公會編號>;
	
	其中 3,4,6,7 僅支持被 script4each 使用, 無法對 script4eachmob 和 script4eachnpc 生效.

可無視外層大括號:
	從 Pandas v1.0.1 版本開始, {<腳本>} 參數中最外層的大括號可以被忽略.

	例如, 以前必須加外層大括號, 否則會報錯:

		script4each "{ getitem 501, 10; }", 0;

	現在, 可以直接忽略最外層大括號, 簡寫變成:

		script4each "getitem 501, 10;", 0;

通過變量返回 GID:
	當 script4each 系列指令即將在某個單位身上執行腳本之前, 會將該單位的 GID 保存到 $@gid
	通過 $@gid 變量保存的內容, 就能利用 unit* 系列指令來操作目標單位.
	
	例如, 以下代碼會讓全服魔物立刻說出自己的名字:

		script4eachmob "{ unittalk $@gid, getunitname($@gid); }", 0;

雙引號轉義: 
	如果 <腳本> 參數中有使用到雙引號的話, 需要在雙引號的左側使用 \ 來進行轉義.
	
	假設我們希望讓全服玩家執行這樣一段腳本: 
	
		announce "角色名稱: " + strcharinfo(0) + " | 角色編號: " + getcharid(0), 0;
	
	那麽上述腳本在使用 script4each 系列指令來執行的時候, <腳本> 參數內的雙引號都需要加 \ 來轉義,
	轉義操作很簡單, 直接將 " 替換成 \" 即可, 最後調用 script4each 時用法如下:
	
		script4each "{ announce \"角色名稱: \" + strcharinfo(0) + \" | 角色編號: \" + getcharid(0), 0; }", 0;
	
字符串變量拼接特別注意:	
	角色名默認也允許玩家使用雙引號, 在這種情況下當您使用 strcharinfo(0) 作為腳本的一部分,
	或者引用其他字符串變量作為腳本的一部分但其內容中可能包含雙引號的時候, 也需要對這些字符串變量的內容進行雙引號轉義.
	
	比較推薦的方法是自己包裝一個轉義函數, 來將 " 替換成 \", 參考代碼如下:
	
		function	script	esc_double_quotation	{
			.@text$ = getarg(0, "");
			.@text$ = replacestr(.@text$, "\"", "\\\"");
			return .@text$;
		}
	
	然後在拼接 script4each 用於執行的腳本時, 參與拼接的字符串變量都套上它:
	
		script4each "{ announce \"角色名稱: \" + esc_double_quotation(strcharinfo(0)) + \" | 角色編號: \" + getcharid(0), 0; }", 0;
	
	這樣就是比較完備和嚴謹的做法了, 哪怕角色名帶雙引號也不會導致腳本解析失敗.
	之所以不推薦使用 escape_sql 指令來進行轉義, 是因為它除了轉義雙引號還會處理單引號等其他符號, 而我們只關心雙引號.

支持調用事件標簽:
	從 Pandas v1.0.2 版本開始, {<腳本>} 參數支持直接調用指定的 NPCNAME::EVENT 事件標簽.
	
	有時我們的 {<腳本>} 參數需要寫入大量覆雜的條件判斷, 若只寫成一行,
	那麽可讀性會很差, 大量的轉義操作都過於繁瑣.
	
	現在開始你可以將覆雜的腳本邏輯直接定義到某個 NPCNAME::EVENT 事件標簽中,
	並在 script4each 系列指令中通過 {<腳本>} 參數直接調用, 方法如下:
	
	-	script	elabel_demo	-1,{
	end;
	OnLoveTest:
		unittalk $@gid, "我的名稱是: " + getunitname($@gid);
	end;
	}
	
	prontera,150,150,4	script	elabel_test	123,{
		// 使全服玩家執行 elabel_demo::OnLoveTest 事件標簽對應的腳本
		script4each "elabel_demo::OnLoveTest",0;
	}

注意事項:
	請注意給該系列指令指定 <腳本的執行範圍> 使盡量合理.
	例如服務端默認情況下加載的 NPC 腳本, 總共就包含 2 萬個 NPC 單位,
	若頻繁使用 script4eachnpc 且將 <腳本的執行範圍> 設置為 0 的話, {<腳本>} 就會在 2 萬個 NPC 上頻繁執行.
	使用不當的話, 會比較容易導致服務器出現卡頓的現象.
	
	若使用 NPCNAME::EVENT 方式調用 script4each 系列指令的話, 雙引號內 NPCNAME::EVENT 的左右請不要加空格:

		script4each "elabel_demo::OnLoveTest",0;	// 正確示例
		script4each " elabel_demo::OnLoveTest",0;	// 錯誤示例: elabel_demo 左側有個空格
		script4each "elabel_demo::OnLoveTest ",0;	// 錯誤示例: OnLoveTest 右側有個空格

	否則可能會找不到對應的 NPCNAME::EVENT, 從而導致引擎將 {<腳本>} 的內容當做常規腳本進行語法解析, 最終報錯.

返回值:
	該指令無論成功失敗, 都不會有返回值

--------------------------------------------------------------

*searcharray <數組變量>,<要查找的字符串或數值>;

查詢數組中第一次出現待查詢內容的索引序號, 使用它來搜索數組內容很方便.

不推薦使用:
	rAthena 已經推出了功能近似的指令 inarray;
	建議優先使用 rAthena 官方指令, 以便確保最大的腳本兼容性.

返回值:
	若查不到結果則返回 -1, 否則返回大於等於 0 的索引序號

--------------------------------------------------------------

*getsameipinfo {<"IP地址">{,<"地圖名">}};

獲得某個指定 IP 在線的玩家信息.
若不指定任何參數, 則默認查詢當前腳本關聯角色的 IP 地址.

IP地址:
	可選參數, 若需要指定的話請填寫標準的 4 段式 IP 地址,
	例如: getsameipinfo "114.114.114.114"

地圖名:
	可選參數, 若想指定此參數則必須先指定<"IP地址">
	地圖名不需要添加 .gat 後綴

信息通過變量返回:

	@sameip_aid[]		該 IP 在線的玩家賬號編號數組 - 數值型數組
	@sameip_cid[]		該 IP 在線的玩家角色編號數組 - 數值型數組
	@sameip_name$[]		該 IP 在線的玩家角色名稱數組 - 字符型數組

返回值及 @sameip_amount 變量都會賦予目前使用指定IP登錄的玩家個數.

提示信息:
	官方自帶的 getcharip 腳本指令可以獲得某個玩家的 IP 地址, 
	配合這個指令就能知道對方相同 IP 下有幾個角色在線.

返回值:
	出錯返回 -1, 其他含 0 正整數表示查到的此 IP 的在線玩家數

示例代碼:
	// 查詢全服範圍內, 和當前角色 IP 相同的玩家信息和數量
	getsameipinfo(getcharip());
	
	// 查詢普隆德拉地圖中, 和當前角色 IP 相同的玩家信息和數量
	getsameipinfo(getcharip(), "prontera");
	
	// 查詢和當前角色相同的地圖中, 和當前角色 IP 相同的玩家信息和數量
	getsameipinfo(getcharip(), strcharinfo(3));

--------------------------------------------------------------

*logout <登出理由>{,"<角色名稱>"|<賬號編號>|<角色編號>};

使指定的角色立刻登出遊戲(踢下線), 此處的"登出理由"只能做參考,
不同的理由編號會讓客戶端給玩家顯示不同的 msgstringtable 提示文本:

登出理由:
	0 = BAN_UNFAIR
	1 = 服務器已關閉 -> MsgStringTable[4]
	2 = ID already logged in -> MsgStringTable[5]
	3 = 連接超時 / 網絡延遲不穩定 -> MsgStringTable[241]
	4 = 服務器已經滿員 -> MsgStringTable[264]
	5 = underaged -> MsgStringTable[305]
	8 = Server sill recognizes last connection -> MsgStringTable[441]
	9 = too many connections from this ip -> MsgStringTable[529]
	10 = out of available time paid for -> MsgStringTable[530]
	11 = BAN_PAY_SUSPEND
	12 = BAN_PAY_CHANGE
	13 = BAN_PAY_WRONGIP
	14 = BAN_PAY_PNGAMEROOM
	15 = 被 GM 踢下線 -> if( servicetype == taiwan ) MsgStringTable[579]
	16 = BAN_JAPAN_REFUSE1
	17 = BAN_JAPAN_REFUSE2
	18 = BAN_INFORMATION_REMAINED_ANOTHER_ACCOUNT
	100 = BAN_PC_IP_UNFAIR
	101 = BAN_PC_IP_COUNT_ALL
	102 = BAN_PC_IP_COUNT
	103 = BAN_GRAVITY_MEM_AGREE
	104 = BAN_GAME_MEM_AGREE
	105 = BAN_HAN_VALID
	106 = BAN_PC_IP_LIMIT_ACCESS
	107 = BAN_OVER_CHARACTER_LIST
	108 = BAN_IP_BLOCK
	109 = BAN_INVALID_PWD_CNT
	110 = BAN_NOT_ALLOWED_JOBCLASS
	111 = 與服務器斷開連接 -> MsgStringTable[3]

返回值:
	該指令無論成功失敗, 都不會有返回值

--------------------------------------------------------------

*warppartyrevive "<to_mapname>",<x>,<y>,<party_id>,{"<from_mapname>",<range x>,<range y>};
*warpparty2 "<to_mapname>",<x>,<y>,<party_id>,{"<from_mapname>",<range x>,<range y>};

該指令的用法與 warpparty 完全一樣, 都是將指定隊伍全員傳送到指定目的地.

區別在於: 
	warpparty 對已經死亡的隊友則無效 (死亡的隊友會被留在原地),
	warppartyrevive 對已經死亡的隊友有效 (隊友會被立刻覆活, 並一起被傳送走).

返回值:
	該指令無論成功失敗, 都不會有返回值

--------------------------------------------------------------

*getareagid <返回數組>,<搜索範圍>{,<動態參數>...};

獲取指定範圍內特定類型單位的全部 GID, 並返回到指定的數組中.

返回數組:
	必填項, 需要指定一個用於返回GID的數值型數組
	若給定的是角色相關變量 (比如角色變量級的數組), 那麽腳本必須關聯到某個玩家
	若給定的是系統相關變量 (比如地圖服務器的數組), 那麽腳本無需關聯到某個玩家

搜索範圍:
	指定地圖上的全部玩家				- getareagid <返回數組>,0,<想搜索的單位類型>,<"地圖名稱">;
	以地圖某個點為中心半徑距離內的玩家	- getareagid <返回數組>,1,<想搜索的單位類型>,<"地圖名稱">,<中心坐標x>,<中心坐標y>,<範圍>;
	指定區域內的全部玩家				- getareagid <返回數組>,2,<想搜索的單位類型>,<"地圖名稱">,<坐標x0>,<坐標y0>,<坐標x1>,<坐標y1>;

想搜索的單位類型:
	BL_PC		- 玩家角色單位
	BL_MOB		- 魔物單位
	BL_PET		- 寵物單位
	BL_HOM		- 人工生命體單位
	BL_MER		- 傭兵單位
	BL_ITEM		- 物品單位
	BL_SKILL	- 技能單位
	BL_NPC		- NPC單位
	BL_CHAT		- 聊天室單位
	BL_ELEM		- 元素精靈單位
	BL_ALL		- 全部單位類型

地圖名稱:
	指定的地圖名稱, 比如 "prontera" 表示普隆德拉
	地圖名稱可以設置為 "this", 表示獲取當前腳本關聯玩家所在的地圖

注意事項:
	該指令被重新設計過, 參數相比 rAthenaCN 老版本有所不同, 使用時需要注意.

返回值:
	操作失敗返回 -1, 其他含 0 正整數表示搜索到的 GID 數量

--------------------------------------------------------------

*getiteminfo(<物品編號>,<查詢的信息類型>{,<用於返回附加數據的數組>})

在 rAthena 原來的參數代碼基礎上, Giraffe<模擬器>新增了一些查詢信息類型.

注意事項:
	從 Pandas v1.0.1 版本開始, -5 類型的返回值不再直接返回支持捕捉的魔物編號

查詢的信息類型 (注意: 傳入參數是負數):
	-1	-	是否可精煉
	-2	-	交易限制掩碼
	-3	-	避免物品被玩家主動使用而消耗
	-4	-	避免物品被作為發動技能的必要道具而消耗		
	-5	-	是否為寵物捕捉道具
	-6	-	是否在其使用腳本中調用了 callfunc 指令
	-7	-	返回物品的 "使用腳本" 字符串
	-8	-	返回物品的 "裝備腳本" 字符串
	-9	-	返回物品的 "卸裝腳本" 字符串

返回值:
	-1	-	返回 1 表示可以精煉, 0 表示不能精煉
	-2	-	返回該物品在 item_trade 數據庫中第二列定義的值
	-3	-	返回 1 表示可以避免消耗, 0 表示不避免消耗
	-4	-	返回 1 表示可以避免消耗, 0 表示不避免消耗
	-5	-	返回 1 表示這是一個寵物捕捉道具 (<用於返回附加數據的數組> 將返回支持捕捉的魔物編號), 0 表示不是
	-6	-	返回 0 表示沒有調用 callfunc 函數, 返回 1 表示調用了 callfunc 函數
	-7	-	返回字符串內容, 包含物品的 "使用腳本" 字符串
	-8	-	返回字符串內容, 包含物品的 "裝備腳本" 字符串
	-9	-	返回字符串內容, 包含物品的 "卸裝腳本" 字符串
	
	其中 -5 和 -6 若返回 -2 則表示未編譯此功能
	其中 -7 到 -9 若返回 UnCompiled 字符串則表示未編譯此功能
	以上全部信息類型, 若返回 -1 表示這個物品編號是不存在或無效的.

用於返回附加數據的數組:
	目前僅 -5 類型會使用到, 如果查詢 -5 類型的時候指定 <用於返回附加數據的數組>
	那麽該道具支持捕捉的魔物編號將會填充到這個數組中 (注意: 只能使用數值型數組).

示例代碼:
	prontera,150,150,5	script	查詢抓寵道具	123,{
		mes "[查詢抓寵道具]";
		mes "請輸入要查詢的道具編號.";
		next;
		
		input .@nameid;
		cleararray .@taming_mobid, 0, getarraysize(.@taming_mobid);
		.@result = getiteminfo(.@nameid, -5, .@taming_mobid);
		
		if (.@result == -1) {
			mes "[查詢抓寵道具]";
			mes "道具編號: " + .@nameid;
			mes "查詢結論: 道具編號不存在或無效";
		}
		else if (.@result == -2) {
			mes "[查詢抓寵道具]";
			mes "道具編號: " + .@nameid;
			mes "查詢結論: 此功能未編譯到代碼中";
		}
		else if (.@result == 1) {
			mes "[查詢抓寵道具]";
			mes "道具編號: " + .@nameid;
			mes "查詢結論: 這是抓寵道具, 能抓:";
			mes "==========";
			for (.@i = 0; .@i < getarraysize(.@taming_mobid); .@i++) {
				mes "> 魔物編號: " + .@taming_mobid[.@i];
			}
		}
		else {
			mes "[查詢抓寵道具]";
			mes "道具編號: " + .@nameid;
			mes "查詢結論: 這應該不是抓寵道具";
		}
		close;
	}

--------------------------------------------------------------

*processhalt {<是否設置中斷>};

該指令只能在事件處理腳本中使用.
設置中斷可以打斷本次事件腳本結束後的源代碼後續邏輯.

每個事件的源代碼後續邏輯各有不同, 且只能用於部分事件, 詳情請參考事件說明文檔.

是否設置中斷:
	可選參數, 填寫 0 表示取消中斷, 填寫 1 表示設置中斷.
	若不攜帶該參數則默認為: 1 - 設置中斷

返回值:
	該指令無論成功失敗, 都不會有返回值

--------------------------------------------------------------

*settrigger <事件的常量名稱>,<觸發行為>;

使用該指令可以設置某個事件或過濾器的觸發行為

事件的常量名稱:
	每個事件或過濾器在代碼中都有自己的常量名稱, 對照如下:
	
	NPCE_LOGIN				-	OnPCLoginEvent
	NPCE_LOGOUT				-	OnPCLogoutEvent
	NPCE_LOADMAP			-	OnPCLoadMapEvent
	NPCE_BASELVUP			-	OnPCBaseLvUpEvent
	NPCE_JOBLVUP			-	OnPCJobLvUpEvent
	NPCE_DIE				-	OnPCDieEvent
	NPCE_KILLPC				-	OnPCKillEvent
	NPCE_KILLNPC			-	OnNPCKillEvent
	NPCE_STATCALC			-	OnPCStatCalcEvent
	
	NPCF_IDENTIFY			-	OnPCIdentifyFilter
	NPCF_ENTERCHAT			-	OnPCInChatroomFilter
	NPCF_INSERT_CARD		-	OnPCInsertCardFilter
	NPCF_USE_ITEM			-	OnPCUseItemFilter
	NPCF_USE_SKILL			-	OnPCUseSkillFilter
	NPCF_ROULETTE_OPEN		-	OnPCOpenRouletteFilter
	NPCF_VIEW_EQUIP			-	OnPCViewEquipFilter
	NPCF_EQUIP				-	OnPCEquipFilter
	NPCF_UNEQUIP			-	OnPCUnequipFilter
	NPCF_CHANGETITLE		-	OnPCChangeTitleFilter
	NPCF_SC_START			-	OnPCBuffStartFilter
	
	NPCE_KILLMVP			-	OnPCKillMvpEvent
	NPCE_IDENTIFY			-	OnPCIdentifyEvent
	NPCE_INSERT_CARD		-	OnPCInsertCardEvent
	NPCE_USE_ITEM			-	OnPCUseItemEvent
	NPCE_USE_SKILL			-	OnPCUseSkillEvent
	NPCE_EQUIP				-	OnPCEquipEvent
	NPCE_UNEQUIP			-	OnPCUnequipEvent

	NPCX_SC_START			-	OnPCBuffStartExpress
	NPCX_SC_END				-	OnPCBuffEndExpress
	NPCX_ENTERMAP			-	OnPCEnterMapExpress
	NPCX_PROGRESSABORT		-	OnPCProgressAbortExpress

觸發行為:
	EVENT_TRIGGER_DISABLED	- 禁止觸發此事件或過濾器
	EVENT_TRIGGER_ONCE		- 允許下次觸發此事件或過濾器
	EVENT_TRIGGER_EVER		- 允許永久觸發此事件或過濾器

--------------------------------------------------------------

*messagecolor "<消息文本>"{,"<文本顏色代碼>",<發送目標>,<遊戲單位編號>};

使用該指令可以發送指定顏色的消息文本到聊天窗口中.
除了發送者以外的其他角色可以見到消息發送者角色頭上頂著文本氣泡.

消息文本:
	消息的正文, 字符串類型, 沒什麽特別的.

文本顏色代碼:
	可選參數, 默認發送的字體顏色為白色.
	該參數使用 RRGGBB 格式的字符串來傳遞色值, 例如紅色是: "ff0000"

發送目標:
	bc_all  : 全服務器的在線玩家都可見.
	bc_map  : 與發送者處於相同地圖的玩家都可見.
	bc_area : 發送者視野範圍內的玩家可見 (默認值).
	bc_self : 僅發送者自己可見.

遊戲單位編號:
	默認情況下的發送者就是使用該指令腳本所關聯的玩家,
	必要的情況下您可以使用這個參數來指定其他的發送者, 以便達到想要的效果.

	這個編號有不同的叫法: GameID, GID, MapID 等
	每一個遊戲中的對象只要會顯示在地圖上的, 就會有一個自己的 <遊戲單位編號>
	遊戲玩家進入遊戲後, 它的 <賬號編號> 就是他角色的 <遊戲單位編號>

--------------------------------------------------------------

*copynpc "<覆制出來的新NPC所在地圖名稱>,<X坐標>,<Y坐標>,<朝向編號>","duplicate(<來源NPC名稱>)","<覆制出來的新NPC名稱>","<圖檔外觀編號>";
*copynpc "<覆制出來的新NPC所在地圖名稱>",<X坐標>,<Y坐標>,<朝向編號>,"<來源NPC名稱>","<覆制出來的新NPC名稱>",<圖檔外觀編號>;

使用該指令可以覆制指定的 NPC 到一個新的位置.
該指令從 v1.0.1 版本開始, 擁有兩個不同的參數版本可供隨意選擇, 程序將根據參數的個數進行自動識別.

四參數版本:

	需要攜帶 4 個字符串參數, 參數的內容需要腳本作者進行準確的拼接操作.

	參數看起來很多, 實際上是由 4 個字符串參數組成的,
	這 4 個字符串與使用 duplicate 進行靜態覆制時候的四個用 %TAB% 分隔的內容是一樣的.

	參數說明:
		第一個參數: 字符串類型	-	"<覆制出來的新NPC所在地圖名稱>,<X坐標>,<Y坐標>,<朝向編號>"
		第二個參數: 字符串類型	-	"duplicate(<來源NPC名稱>)"
		第三個參數: 字符串類型	-	"<覆制出來的新NPC名稱>"
		第四個參數: 字符串類型	-	"<圖檔外觀編號>"

	舉例說明:
		假設有以下 NPC 我們想把它覆制一個新的出來:

			prontera,146,99,2	script	PVP管理員::PVPCOPYTEST	123,{
				mes "[PVP管理員]";
				mes "場地正在修理, 請稍後再來...";
				close;
			}

		通常的做法是在腳本中, 使用 duplicate 指令進行靜態覆制, 如:
		
			prontera,156,99,2	duplicate(PVPCOPYTEST)	PVP管理員#1	123
		
		現在你可以使用 copynpc 腳本指令, 將上面這一行靜態覆制代碼按 %TAB% 分割為4個字段,
		然後以字符串形式傳遞給 copynpc 腳本指令, 如:
		
			copynpc "prontera,156,99,2","duplicate(PVPCOPYTEST)","PVP管理員#2","123";
			
			這里第二個參數支持簡化 duplicate 關鍵字, 可以用以下語句實現同樣的效果:
			
			copynpc "prontera,156,99,2","PVPCOPYTEST","PVP管理員#2","123";
		
		同時此函數支持返回覆制出來的新 NPC 的 GID, 方便你使用 unit 系列指令對其進行操作, 如:
		
			.@gid = copynpc("prontera,156,99,2","duplicate(PVPCOPYTEST)","PVP管理員#3","123");
			unittalk .@gid, "我是新克隆出來的 NPC 我的 GID 是 : " + .@gid;
		
		如果想要覆制一個副本中的 NPC, 那麽需要在用到地圖名稱的地方使用 instance_mapname 進行轉換,
		原始 NPC 的名稱也需要用 instance_npcname 進行轉換, 如:
		
			.@w1$ = instance_mapname("1@tower") + ",156,99,2";
			.@w2$ = "duplicate(" + instance_npcname("PVPCOPYTEST") + ")";
			.@w3$ = "PVP管理員#4";
			.@w4$ = "123";
			
			copynpc .@w1$, .@w2$, .@w3$, .@w4$;

七參數版本:

	需要攜帶 7 個參數, 參數的內容可以直接用對應類型的變量直接傳遞, 更方便理解.
	
	參數說明:
		第一個參數: 字符串類型	-	"<覆制出來的新NPC所在地圖名稱>"
		第二個參數: 數值類型	-	<X坐標>
		第三個參數: 數值類型	-	<Y坐標>
		第四個參數: 數值類型	-	<朝向編號>
		第五個參數: 字符串類型	-	"<來源NPC名稱>"
		第六個參數: 字符串類型	-	"<覆制出來的新NPC名稱>"
		第七個參數: 數值類型	-	<圖檔外觀編號>

	舉例說明:
		假設有以下 NPC 我們想把它覆制一個新的出來:

			prontera,146,99,2    script    PVP管理員::PVPCOPYTEST    123,{
				mes "[PVP管理員]";
				mes "場地正在修理, 請稍後再來...";
				close;
			}

		通常的做法是在腳本中, 使用 duplicate 指令進行靜態覆制, 如:
		
			prontera,156,99,2	duplicate(PVPCOPYTEST)	PVP管理員#1	123
		
		現在你可以使用 copynpc 腳本指令直接覆制:
		
			copynpc "prontera",156,99,2,"duplicate(PVPCOPYTEST)","PVP管理員#2",123;
			
			這里第二個參數支持簡化 duplicate 關鍵字, 可以用以下語句實現同樣的效果:
			
			copynpc "prontera",156,99,2,"PVPCOPYTEST","PVP管理員#2",123;
		
		同時此函數支持返回覆制出來的新 NPC 的 GID, 方便你使用 unit 系列指令對其進行操作, 如:
		
			.@gid = copynpc("prontera",156,99,2,"PVPCOPYTEST","PVP管理員#3",123);
			unittalk .@gid, "我是新克隆出來的 NPC 我的 GID 是 : " + .@gid;
		
		如果想要覆制一個副本中的 NPC, 那麽需要在用到地圖名稱的地方使用 instance_mapname 進行轉換,
		原始 NPC 的名稱也需要用 instance_npcname 進行轉換, 如:
		
			copynpc instance_mapname("1@tower"),156,99,2,instance_npcname("PVPCOPYTEST"),"PVP管理員#4",123;

公用說明:

	返回值:
		覆制成功則返回覆制出來的新 NPC 的 GID, 失敗則返回 0

	注意事項:
		覆制商店類型的 NPC 時, 來源 NPC 和目標 NPC 它們之間的道具列表是相互獨立的.
		
		若指定了一個無效的外觀編號, 那麽地圖服務器雖然會報 status_set_viewdata 錯誤,
		但是實際上 NPC 還是會覆制成功 (只不過你看不見它).
		此時可以用 setunitdata 調整這個 NPC 的 UNPC_DISPLAY 參數, 重新給他一個外觀.

--------------------------------------------------------------

*gettimefmt <"時間格式化標準">{,<要轉換的秒數>{,<是否格式化成 UTC 時間>}};

時間格式化標準:
	與 gettimestr 函數的第一個參數完全一樣.
	可以參考: https://www.runoob.com/cprogramming/c-function-strftime.html

要轉換的秒數:
	可選參數, 如果你指定了一個秒數, 那麽指令將不會轉換當前系統時間, 而是轉換你給定的時間

是否格式化成 UTC 時間:
	可選參數, 默認值為 0, 填寫 1 表示是. 如果格式化成 UTC 時間, 則不會包含時區.
	
	dispbottom gettimefmt("%H:%M:%S", 10);		// 在北京的話, 返回: 08:00:10 (北京時區是 UTC + 08:00:00)
	dispbottom gettimefmt("%H:%M:%S", 10, 1);	// 返回: 00:00:10

返回值:
	成功則返回被格式化的時間, 失敗則返回空字符串

--------------------------------------------------------------

*mpet <魔物編號>{,<魔物編號>...}
*multicatchpet <魔物編號>{,<魔物編號>...}

與 pet / catchpet 指令類似, 但可以設定多個支持捕捉的魔物編號

魔物編號:
	必須是存在於 db/{pre-}re/pet_db.yml 中定義的魔物編號
	沒有定義在 pet_db.yml 的魔物, 我們無法知道它的食物和饑餓率等數據

返回值:
	該指令無論成功失敗, 都不會有返回值

--------------------------------------------------------------

*selfdeletion {<自毀策略>}

該指令與 unloadnpc 類似, 但可以控制自毀當前 NPC,
包括一些更細膩的自毀時機控制. 哪怕 NPC 沒有關聯到玩家, 也可以完成自毀.

自毀策略:
	SELFDEL_NOW       - 控制當前 NPC 終止全部正在與其交互的玩家對話, 並立刻自毀 (默認值)
	SELFDEL_WAITFREE  - 當最後一個正在與其交互的玩家對話結束後, 再進行自毀 (無論是否有工作中的定時器)
	SELFDEL_CANCEL    - 取消 SELFDEL_WAITFREE 設置的自毀標記

返回值:
	該指令無論成功失敗, 都不會有返回值

場景建議:
	常用於配合 copynpc 指令, 實現進行挖礦\釣魚\開寶箱等與 NPC 對話完畢後 NPC 會消失的場景.

注意事項:
	在 NPC 中 callfunc 某個 function, 在這個 function 中調用的 selfdeletion 將對調用者 NPC 生效.

--------------------------------------------------------------

*setchartitle <稱號ID>{,<角色編號>};

設置指定玩家角色的稱號ID
該指令只在客戶端封包版本大於等於 20150513 的時候有效.

稱號ID:
	稱號ID在客戶端的 data\luafiles514\lua files\datainfo\titletable.lub 中獲取.
	服務端並不清楚客戶端會將某個稱號ID呈現出什麽樣的字符串.

返回值:
	設置成功則返回 1, 設置失敗則返回 0

--------------------------------------------------------------

*getchartitle {<角色編號>};

獲得指定玩家角色的稱號ID
該指令只在客戶端封包版本大於等於 20150513 的時候有效.

返回值:
	設置成功則返回目標玩家的稱號ID (若為 0 則表示此玩家沒有稱號)
	獲取失敗則返回 -1

--------------------------------------------------------------

*npcexists "<NPC名稱>"{,<用於保存 GameID 的變量>};

判斷指定名稱的 NPC 是否存在, 就算 NPC 不存在控制台也不會報錯
不過用法錯誤的話還是一樣會報錯的, 比如: 第二個參數傳遞了一個字符串變量

NPC名稱:
	想要確認的 NPC 名稱, 需要使用 NPC 的唯一名稱 (::name)
	技巧: 寫腳本之前可以使用 strnpcinfo 類型 3 來查詢當前 NPC 的唯一名稱.
	就是名字最長, 且全服唯一的那個 NPC 名稱就是了.

用於保存 GameID 的變量:
	有時候當你確認某個 NPC 存在後, 可能希望對此單位進行其他操作
	那麽可以傳遞一個"數值型"的變量, 如果目標單位存在, 那麽程序將自動填充 GameID 返回
	如果目標單位不存在, 那麽指定的變量內容將會被設置為 0

返回值:
	存在返回 1, 不存在返回 0

--------------------------------------------------------------

*storagegetitem <物品編號>,<數量>{,<賬號編號>};
*storagegetitem "<物品名稱>",<數量>{,<賬號編號>};

該指令能夠直接往個人倉庫創建指定的道具.
在個人倉庫處於關閉狀態的時候才能使用該指令來創建道具.
若倉庫已滿且創建的道具可被丟在地上, 那麽道具將會被丟在角色附近的地面上.

物品編號/名稱:
	想要創建到倉庫的物品編號, 或者物品名稱.

數量:
	想要創建的道具數量, 若是不可堆疊的道具, 則會被創建多個.

賬號編號:
	可選參數, 若指定了對應的賬號編號, 則操作的是指定賬號的倉庫.
	若不提供此參數則關聯當前調用該指令的玩家.

注意事項:
	密集調用該指令時(比如寫個循環調用幾百次), 調用者玩家可能會卡一下.
	
	為了降低性能影響, 執行該指令後不會立刻強制服務器保存倉庫內容.
	需要等待下一次自動保存數據時, 才會將最新的倉庫數據發給角色服務器保存.

返回值:
	添加成功則返回 0, 若失敗則返回小於 0 的錯誤代碼:

	-1	-	指定的物品不存在
	-2	-	指定的物品數量不合法 (比如給了個負數)
	-3	-	None
	-4	-	沒有關聯到玩家, 因此無法找到對應的個人倉庫
	-5	-	當前倉庫處於打開狀態, 需要先關閉倉庫才能繼續使用
	-6	-	指定的道具不能存放到倉庫
	-7	-	本指令暫時不支持創建寵物蛋道具
	-8	-	您沒有權限往個人倉庫存儲道具 (基本不可能發生)
	-9	-	道具放入倉庫時失敗了, 並且該道具也不是可丟棄到地面的道具

--------------------------------------------------------------

*getcharmac <賬戶編號>/<角色編號>/<"角色名稱">;

與 getcharip 類似, 該指令用於獲取玩家登錄時客戶端網卡的 MAC 地址
但必須要求客戶端使用 SSO 方式進行登錄才會有記錄

注意事項:
	如果無法讀取到 MAC 地址, 那麽請先確保客戶端使用 SSO 方式登錄
	如果成功讀取到 MAC 地址, 格式應為: "00-00-00-00-00-00"

使用建議:
	哪怕讀取到的返回值不是空字符串, 也應判斷是否等於 "00-00-00-00-00-00"
	如果等於 "00-00-00-00-00-00" 也可以認為是沒讀取到

返回值:
	成功則返回 MAC 地址, 讀取不到則返回空字符串

--------------------------------------------------------------

*getconstant <"常量字符串">;

查詢一個常量字符串對應的數值. 當你僅知道一個常量字符串, 
且試圖將它轉換成數值參數傳遞給其他函數時使用

返回值:
	成功則返回常量對應的數值, 查詢失敗則返回 -255

--------------------------------------------------------------

*preg_search <"字符串">,<"匹配表達式">,<拓展標記位>,<存放匹配結果的字符串數組>;

執行一個正則表達式搜索並返回首個匹配的分組內容

字符串:
	待匹配的字符串, 正則表達式將從中搜索你需要的信息

匹配表達式:
	正則匹配表達式 (pattern), 程序將根據該表達式提取分組內容

拓展標記位:
	掩碼選項, 目前可選的只有一個值:
	
	1	-	匹配時忽略大小寫

存放匹配結果的字符串數組:
	填寫用於返回分組結果的字符串數組名稱(無需中括號)

返回值:
	返回負數表示錯誤, 其他正整數表示匹配到的分組個數 (其中 0 通常不應該出現, 出現也可以當錯誤)

注意事項:
	讀取數組內容時, 請不要使用 getarraysize 去探測數組的長度.
	因為實際匹配過程中, 如果剛好匹配結果的末尾分組內容為空字符串,
	那麽 getarraysize 讀取數組長度的時候, 它會將空字符串元素忽略, 導致無法獲取正確的數組長度.
	
	如果需要遍歷, 則應該使用函數的返回值來作為數組內容的長度.

示例代碼:
	prontera,150,150,5	script	正則搜索測試	123,{
		// 目標: 提取其中的 HAT_EF_FLUTTER_BUTTERFLY 常量 (左右故意加空格)
		.@text$ = "  hateffect HAT_EF_FLUTTER_BUTTERFLY,true; ";
		
		// 下面是提取用的正則表達式
		// 正則表達式學習成本較高, 一旦掌握, 處理字符串將會達到一個全新的高度
		.@patt$ = ".*?(hateffect(\s{1,}|\()(\(|)\s*(.*?)\s*,\s*(.*?)\s*(|\))(\s*|);)";
		
		// 準備個字符串數組用來存返回的內容 (可以不用特意 setarray, 只是為了示例)
		setarray .@groups$[0],"";
		
		// 注意: 字符串數組名應該以 $ 結尾, 實際傳遞給 preg_search 時無需攜帶中括號
		.@match = preg_search(.@text$, .@patt$, 1, .@groups$);
		
		if (.@match <= 0) {
			dispbottom "很抱歉, 匹配失敗了...";
			end;
		}
		
		// 循環遍歷輸出一下匹配到的內容, 若無意外第 5 個元素 (索引 4) 就是我們要的內容
		for (.@i = 0; .@i < .@match; .@i++) {
			dispbottom ".@groups$[" + .@i + "] = " + .@groups$[.@i];
		}
		
		end;
	}

--------------------------------------------------------------

*aura <光環編號>{,<角色編號>};

使角色可以激活指定的光環特效.
光環本質是一組 Effect 效果的組合, 光環編號定義在 db/aura_db.yml 文件中.

光環編號:
	若光環編號為 0 則表示取消光環

返回值:
	成功返回 1, 失敗返回 0

使用建議:
	若想知道當前角色使用的光環編號, 直接訪問 PANDAS_AURASET 角色變量即可

注意事項:
	在客戶端封包版本小於 20181002 的情況下, 獲取/失去光環的玩家單位客戶端
	會黑屏一下以便刷新光環效果. 為獲取最佳的光環效果, 建議使用客戶端封包
	版本大於等於 20181002 的客戶端.

--------------------------------------------------------------

*unitaura <遊戲單位編號>,<光環編號>;

使指定的單位可以激活指定的光環特效.
光環本質是一組 Effect 效果的組合, 光環編號定義在 db/aura_db.yml 文件中.

若你已經知道某個玩家/魔物/傭兵/寵物/NPC/精靈/人工生命體的 <遊戲單位編號>,
那麽也可以為他們套上一個光環 (但只有玩家的光環會記錄在數據庫中, 並且會在
重啟地圖服務器後還能被恢覆光環, 其他的幾種單位他們的光環會持續生效到地圖
服務器退出為止)

遊戲單位編號:
	這個編號有不同的叫法: GameID, GID, MapID 等
	每一個遊戲中的對象只要會顯示在地圖上的, 就會有一個自己的 <遊戲單位編號>
	遊戲玩家進入遊戲後, 它的 <賬號編號> 就是他角色的 <遊戲單位編號>	

光環編號:
	若光環編號為 0 則表示取消光環

返回值:
	成功返回 1, 失敗返回 0

注意事項:
	在客戶端封包版本小於 20181002 的情況下, 獲取/失去光環的玩家單位客戶端
	會黑屏一下以便刷新光環效果. 為獲取最佳的光環效果, 建議使用客戶端封包
	版本大於等於 20181002 的客戶端.

--------------------------------------------------------------

*getunitdata <遊戲單位編號>,<用於保存返回數據的數組名稱>;
*setunitdata <遊戲單位編號>,<參數>,<新的值>;

在原先 rAthena 官方返回的信息基礎上, <參數>和<返回的數組>中新增了以下索引:

	UMOB_AURA - 讀取或設置魔物的光環編號
	UHOM_AURA - 讀取或設置生命體的光環編號
	UPET_AURA - 讀取或設置寵物的光環編號
	UMER_AURA - 讀取或設置傭兵的光環編號
	UELE_AURA - 讀取或設置精靈的光環編號
	UNPC_AURA - 讀取或設置NPC 的光環編號
	
	UMOB_DAMAGETAKEN - 讀取或設置指定魔物的承傷倍率
		若值為 -1 則表示直接使用魔物在 db 中設置的默認承傷倍率
		設為 100 則表示魔物受到的傷害是 100%
		設為 80 則表示玩家給魔物造成的傷害只會發揮 80% 的傷害量
		設為 120 則表示玩家給魔物造成的傷害將發揮 120% 的傷害量
		取值範圍: 從 -1 到 65535
	UMOB_DAMAGETAKEN_DB - 讀取指定魔物在 db 中設置的默認承傷倍率
		注意: 該參數不能用於 setunitdata 指令
	
	UMOB_MOBBASEEXP - 讀取或設置魔物的基礎經驗值
		若值為 -1 則表示直接使用魔物在 db 中設置的默認基礎經驗值
		取值範圍: 從 -1 到 (2^63 - 1)
		注意: 此經驗值在最終給玩家的時候會經歷各種加成計算, 比如: 經驗倍增書、VIP 會員加成等
	UMOB_MOBBASEEXP_DB - 讀取指定魔物在 db 中設置的默認基礎經驗值
		注意: 該參數不能用於 setunitdata 指令

	UMOB_MOBJOBEXP - 讀取或設置魔物的職業經驗值
		若值為 -1 則表示直接使用魔物在 db 中設置的默認職業經驗值
		取值範圍: 從 -1 到 (2^63 - 1)
		注意: 此經驗值在最終給玩家的時候會經歷各種加成計算, 比如: 經驗倍增書、VIP 會員加成等
	UMOB_MOBJOBEXP_DB - 讀取指定魔物在 db 中設置的默認職業經驗值
		注意: 該參數不能用於 setunitdata 指令

--------------------------------------------------------------

*getunittarget <遊戲單位編號>;

獲取指定單位當前正在攻擊的目標單位編號.
支持的單位類型: 玩家/魔物/傭兵/寵物/NPC/精靈/人工生命體

遊戲單位編號:
	這個編號有不同的叫法: GameID, GID, MapID 等
	每一個遊戲中的對象只要會顯示在地圖上的, 就會有一個自己的 <遊戲單位編號>
	遊戲玩家進入遊戲後, 它的 <賬號編號> 就是他角色的 <遊戲單位編號>	

返回值:
	返回 0 表示沒有攻擊目標, 非零則代表: 目標的遊戲單位編號

注意事項:
	若給定的遊戲單位編號不存在, 返回值也是 0

--------------------------------------------------------------

*unlockcmd;

解鎖實時事件和過濾器事件的指令限制, 只能用於實時或過濾器事件

返回值:
	該指令沒有任何返回值

提示信息:
	用法和 disable_items; 類似, 直接調用即可 

--------------------------------------------------------------

*batrec_query <記錄宿主的單位編號>,<交互目標的單位編號>,<記錄類型>{,<聚合規則>};

該指令可以查詢指定單位的戰鬥記錄, 確認與交互目標單位產生的具體記錄值.

記錄宿主的單位編號:
	比如想查詢某個魔物的戰鬥記錄, 那就傳遞此魔物的遊戲單位編號

交互目標的單位編號:
	比如想查詢玩家對魔物的記錄值(或者叫: 傷害值), 則此處傳遞玩家的遊戲單位編號(賬號編號)

記錄類型:
	BRT_DMG_RECEIVE		- 承傷記錄 (記錄宿主受到交互目標的傷害記錄)
	BRT_DMG_CAUSE		- 輸出記錄 (記錄宿主攻擊交互目標的傷害記錄)

聚合規則:
	BRA_COMBINE			- 按主人為單位合並查詢, 默認值 (寵物/傭兵等擁有主人的生命體, 傷害值計算到主人頭上)
	BRA_DISCRETE		- 按獨立單位進行查詢 (可以單獨查詢寵物/傭兵對記錄宿主的(被)攻擊記錄)

返回值:
	返回 -1 表示查無記錄, 含 0 正整數表示傷害值

提示信息:
	若返回的傷害值是 0, 則表示交互單位和宿主之間發生了沒有傷害的技能交互 (比如: 緩速術)
	
	每個單位都有自己的戰鬥記錄信息, 單位被銷毀之前記錄都在.
	記錄數上限沒有限制, 但越多的記錄會開銷越多內存.
	
	您可以在 OnUnitKillExpress 單位死亡事件中獲取戰鬥記錄的內容以便立即使用它們,
	或者將戰鬥記錄數組保存到其他地方.

--------------------------------------------------------------

*batrec_rank <記錄宿主的單位編號>,<返回交互目標的單位編號數組>,<返回記錄值數組>,<記錄類型>{,<聚合規則>{,<排序規則>}};

查詢指定單位的戰鬥記錄並對記錄的值進行排序, 返回排行榜單

記錄宿主的單位編號:
	比如想查詢某個魔物的戰鬥記錄, 那就傳遞此魔物的遊戲單位編號

返回交互目標的單位編號數組:
	指定一個數值型數組, 用於接收按序排列後的遊戲單位編號.
	提示: 無論調用成功與否該數組的內容都將被清空
	
	注意: 玩家單位返回的是角色編號而不是遊戲單位編號.
	若需獲取玩家的遊戲單位編號, 建議用: convertpcinfo 指令進行轉換.

返回記錄值數組:
	指定一個數值型數組, 用於接收與單位編號數組一一對應的記錄值.
	提示: 無論調用成功與否該數組的內容都將被清空

記錄類型:
	BRT_DMG_RECEIVE		- 承傷記錄 (記錄宿主受到交互目標的傷害記錄)
	BRT_DMG_CAUSE		- 輸出記錄 (記錄宿主攻擊交互目標的傷害記錄)

聚合規則:
	BRA_COMBINE			- 按主人為單位合並查詢, 默認值 (寵物/傭兵等擁有主人的生命體, 傷害值計算到主人頭上)
	BRA_DISCRETE		- 按獨立單位進行查詢 (可以單獨查詢寵物/傭兵對記錄宿主的(被)攻擊記錄)

排序規則:
	BRS_DESC			- 排行榜按記錄值降序排列, 默認值 (記錄值越大排名越靠前)
	BRS_ASC				- 排行榜按記錄值升序排列 (記錄值越小排名越靠前)

返回值:
	失敗返回 -1, 含 0 正整數表示數組中返回的榜單記錄數

提示信息:
	若返回的傷害值是 0, 則表示交互單位和宿主之間發生了沒有傷害的技能交互 (比如: 緩速術)
	
	每個單位都有自己的戰鬥記錄信息, 單位被銷毀之前記錄都在.
	記錄數上限沒有限制, 但越多的記錄會開銷越多內存.
	
	您可以在 OnUnitKillExpress 單位死亡事件中獲取戰鬥記錄的內容以便立即使用它們,
	或者將戰鬥記錄數組保存到其他地方.
 
--------------------------------------------------------------

*batrec_sortout <記錄宿主的單位編號>{,<記錄類型>};

該指令移除指定宿主的戰鬥記錄中, 交互單位已經不存在 (或下線) 的記錄

記錄宿主的單位編號:
	比如想處理某個魔物的戰鬥記錄, 那就傳遞此魔物的遊戲單位編號

記錄類型:
	可選, 不傳遞此參數則表示處理全部記錄
	BRT_DMG_RECEIVE		- 承傷記錄 (記錄宿主受到交互目標的傷害記錄)
	BRT_DMG_CAUSE		- 輸出記錄 (記錄宿主攻擊交互目標的傷害記錄)

返回值:
	該指令無論成功與否, 都不會有返回值

--------------------------------------------------------------

*batrec_reset <記錄宿主的單位編號>;

清除指定單位的戰鬥記錄信息

記錄宿主的單位編號:
	比如想清除某個魔物的戰鬥記錄, 那就傳遞此魔物的遊戲單位編號

返回值:
	該指令無論成功與否, 都不會有返回值

--------------------------------------------------------------

*enable_batrec {<遊戲單位編號>};
*disable_batrec {<遊戲單位編號>};

啟用或禁用指定單位的戰鬥記錄.

遊戲單位編號:
	可選值, 若不傳遞則表示控制當前關聯到腳本的角色

提示信息:
	您可以通過 batrec_autoenabled_unit 戰鬥配置選項來控制哪些單位會自動啟用戰鬥記錄.

	玩家默認是不會啟動戰鬥記錄的, 因此需要使用該指令手動開啟.
	玩家角色在開啟記錄後, 除非玩家下線或者被明確的禁用, 否則將會一直記錄.
	
	由於記錄本身沒上限, 因此玩家在線一直玩, 累計攻擊成千上萬個魔物的話,
	在調用 batrec_sortout 進行整理之前, 對這些魔物的輸出和承傷記錄將被長時間保存在內存中.
	
	對於玩家角色來說, 開啟戰鬥記錄後若太久忘記關閉會導致地圖服務器內存占用持續提高.

返回值:
	該指令無論成功與否, 都不會有返回值

--------------------------------------------------------------

*login <角色編號>{,<默認是否坐下>{,<默認身體朝向>{,<默認腦袋朝向>{,<登錄模式>}}}};

將指定的角色以特定的登錄模式拉上線

角色編號:
	指定一個想使之上線的角色編號

默認是否坐下:
	0 表示站立, 1 表示坐下
	可選值, 默認值為: 0

	此選項會被 suspend_{afk|normal|offline}_sitdown 戰鬥配置選項覆蓋
	具體被哪個選項影響取決於 <登錄模式> 的值

默認身體朝向:
    1 = 西北      0 = 正北      7 = 東北
              ↖     |     ↗
    2 = 正西  <-     +     ->   6 = 正東
              ↙     |     ↘
    3 = 西南      4 = 正南      5 = 東南
	可選值, 默認值為: 4 (正南)
	
	此選項會被 suspend_{afk|normal|offline}_bodydirection 戰鬥配置選項覆蓋
	具體被哪個選項影響取決於 <登錄模式> 的值

默認腦袋朝向:
	0 = 相對於身體朝向的正前方, 頭部看向正前方
	1 = 相對於身體朝向的正前方, 頭部看向右看
	2 = 相對於身體朝向的正前方, 頭部看向左看
	可選值, 默認值為: 0 (正前方)
	
	此選項會被 suspend_{afk|normal|offline}_headdirection 戰鬥配置選項覆蓋
	具體被哪個選項影響取決於 <登錄模式> 的值

登錄模式:
	SUSPEND_MODE_OFFLINE	- 掛機模式
	SUSPEND_MODE_AFK		- 離開模式 (AFK)
	SUSPEND_MODE_NORMAL		- 普通模式
	可選值, 默認值為: SUSPEND_MODE_NORMAL

提示信息:
	請不要在 OnInit / OnInterIfInit / OnInterIfInitOnce 事件中使用該指令,
	因為在觸發這幾個事件的時候服務器並未就緒.
	
	若必須要在這個時機使用本指令的話, 可以使用 addtimer 將延遲幾秒再執行.

返回值:
	成功返回 1, 失敗返回 0

--------------------------------------------------------------

*checksuspend {<角色編號|賬號編號|"角色名稱">};

獲取指定角色或指定賬號當前在線角色的掛機模式

角色編號|賬號編號|"角色名稱":
	可選值, 不傳遞則表示檢查當前腳本所關聯的角色

返回值:
	-1 						- 表示指定的角色不存在
	SUSPEND_MODE_NONE		- 角色並沒有處於任何掛機模式
	SUSPEND_MODE_OFFLINE	- 處於 @suspend 指令帶來的離線掛機模式
	SUSPEND_MODE_AFK		- 處於 @afk 指令帶來的離開模式
	SUSPEND_MODE_NORMAL		- 處於 login 腳本指令帶來的普通掛機模式

提示信息:
	若想檢查是否處於離線掛店模式, 可以使用 checkvending 腳本指令

--------------------------------------------------------------

*unitexists <遊戲單位編號>{,<單位是否必須存活>};

用來判斷指定的遊戲單位是否存在.
在 rAthena 的基礎上拓展了 <單位是否必須存活> 參數.

遊戲單位編號:
	這個編號有不同的叫法: GameID, GID, MapID 等
	每一個遊戲中的對象只要會顯示在地圖上的, 就會有一個自己的 <遊戲單位編號>
	遊戲玩家進入遊戲後, 它的 <賬號編號> 就是他角色的 <遊戲單位編號>	

單位是否必須存活:
	可選值, 填寫 1 表示要求單位必須存活才認為單位存在;
	不填或者填寫 0 則認為單位存在就好無需判斷是否存活

返回值:
	指定的單位存在則返回 true 否則返回 false

--------------------------------------------------------------

*bonus_script <"效果腳本代碼">,<生效時長>{,<標記>{,<類型>{,<狀態圖標>{,<角色編號>}}}};

在 rAthena 的功能基礎上, Giraffe<模擬器>拓展了它的返回值.
各參數的詳細說明請直接參考 doc/script_commands.txt 中 bonus_script 的說明.

返回值:
	執行成功則返回該 bonus_script 實例的唯一編號,
	執行失敗, 或者 bonus_script 在沒有指定 2048 強制覆蓋標記的情況下已存在則返回 0.
	此處的唯一編號可以用於 bonus_script_remove 等拓展指令.

注意事項:
	正常情況下連續執行兩次相同的 bonus_script 只有第一次能獲得編號, 如:

		// 第一次, .@bonusid 將返回有效的唯一編號
		.@bonusid = bonus_script("{ bonus bStr,5; }",60);
		
		// 第二次, 沒有特殊指定強制覆蓋標記, 雖然時間會重置, 但返回值將依然是 0
		.@bonusid = bonus_script("{ bonus bStr,5; }",60);

	bonus_script 的 <標記> 允許您設定 2048 來強制重覆 bonus_script 腳本, 如:
	
		// 第一次, .@bonusid 將返回有效的唯一編號, 比如: 644245094400002
		.@bonusid = bonus_script("{ bonus bStr,5; }",60,2048);
	
		// 第二次, .@bonusid 也會返回有效的唯一編號, 但將於第一次創建時的編號不同, 比如: 644245094400003
		.@bonusid = bonus_script("{ bonus bStr,5; }",60,2048);
		
		在這種情況下, 兩次創建的 bonus_script 將同時生效, 在它們同時生效期間角色的 STR 將會是 +10

--------------------------------------------------------------

*bonus_script_remove <效果腳本編號>{,<角色編號>};

用於移除指定的 bonus_script 效果腳本.

效果腳本編號:
	當時調用 bonus_script 指令成功後, 會返回一個效果腳本編號.
	傳入這個編號即可將這個效果腳本移除

返回值:
	成功移除則返回 true, 找不到腳本代碼或移除失敗則返回 false

--------------------------------------------------------------

*bonus_script_list <返回效果腳本編號的數值型數組>{,<角色編號>};

用於獲取指定角色當前激活的全部 bonus_script 效果腳本編號.
效果腳本編號在調用 bonus_script 成功後會返回.

返回效果腳本編號的數值型數組:
	數值類型的數組, 用於接收指定角色當前已被激活的效果腳本編號.
	提示: 無論調用成功與否該數組的內容都將被清空

返回值:
	獲取到的效果腳本編號數量, 發生錯誤則返回 -1

--------------------------------------------------------------

*bonus_script_exists <效果腳本編號>{,<角色編號>};

用於查詢指定角色是否已經激活了特定的 bonus_script 效果腳本.

效果腳本編號:
	當時調用 bonus_script 指令成功後, 會返回一個效果腳本編號.
	傳入這個編號即可查詢該腳本效果是否還存在.

返回值:
	效果存在則返回 true, 角色不在線或效果不存在否則返回 false

--------------------------------------------------------------

*bonus_script_getid <"效果腳本代碼">,<返回效果腳本編號數組>{,<角色編號>};

用於查詢指定效果腳本代碼字符串在指定角色上所對應的效果腳本編號,
若有多個重疊則返回多個效果腳本編號.

效果腳本代碼:
	想要查詢的效果腳本代碼字符串,
	必須和調用 bonus_script 腳本時傳入的第一個參數一模一樣

返回效果腳本編號數組:
	數值類型的數組, 由於同一個角色身上可以通過 bonus_script 的 2048 標記來創建
	多個重疊的效果腳本, 因此這里可能會返回多個效果腳本編號

返回值:
	查詢到的記錄數, 若為 -1 表示出錯; 若為 0 則表示無記錄;
	其他非 0 正整數表示數組中返回的效果腳本編號數量

--------------------------------------------------------------

*bonus_script_info <效果腳本編號>,<查詢類型>{,<角色編號>};

用於查詢指定效果腳本的相關信息.
只需要提供指定的效果腳本編號, 並且該效果在指定角色身上處於激活狀態,
就可以查詢到它的相關信息.

效果腳本編號:
	當時調用 bonus_script 指令成功後, 會返回一個效果腳本編號.
	傳入這個編號即可查詢該腳本效果是否還存在.

查詢類型:
	0	-	效果腳本代碼, 返回字符串類型的值
	1	-	標記位. 即調用 bonus_script 時傳遞的 flag 字段值
	2	-	狀態圖標編號. 即調用 bonus_script 時傳遞的 status_icon 字段值
	3	-	效果類型. 即調用 bonus_script 時傳遞的 type 字段值
	4	-	剩余時間 (單位為毫秒)

返回值:
	若指定的角色不存在則返回 -2
	給定的效果腳本編號不存在則返回 -3
	若給定的查詢類型不在有效的範圍內則返回 -4
	
	其中除查詢類型 1 的返回值為字符串外, 其他查詢類型的返回值皆為數值型.
	其中查詢類型 2 返回 -1 表示沒有圖標.
	其中查詢類型 4 返回 -1 表示該效果腳本永不超時.

--------------------------------------------------------------

*expandinventory_adjust <增加多少容量>;

用於調整角色的背包容量上限.

增加多少容量:
	玩家現在容量是 100 你想把它調整為 115, 那麽此處只需要傳遞 15 即可

返回值:
	調整成功返回 1, 失敗返回 0

注意事項:
	背包擴容是 RO 客戶端支持的一個功能, 最大可以將角色的背包從 100 擴容到 200.
	客戶端則封包版本號必須 >= 20181031 才支持.

--------------------------------------------------------------

*getinventorysize {<角色編號>};

用於查詢並獲取指定角色的背包容量上限.

返回值:
	找不到角色則返回 0, 否則返回查詢到的背包容量

--------------------------------------------------------------

*announce "<消息文本>",<標記位>{,<字體顏色>{,<字體類型>{,<字體大小>{,<字體對齊>{,<字體垂直>{,<角色編號>}}}}}};

在 rAthena 原來的標記位基礎上, Giraffe<模擬器>新增了以下標記位:

標記位:
	bc_name:	在聊天欄中雙擊此消息時會將發布者角色名稱填寫到聊天窗口

示例代碼:
	announce "雙擊這條文本可以私聊我喲",bc_all|bc_name;

提示信息:
	若調用 announce 的腳本沒有關聯到玩家, 那麽 bc_name 標記位將會被忽視.
	
	由於客戶端限制, 在設置上 bc_name 標記位後, 除了<字體顏色>字段依然有效外, 其他像:
	<字體類型>,<字體大小>,<字體對齊>,<字體垂直> 等字段將被忽視.

注意事項:
	發送者自己雙擊聊天欄中的公告信息是無效的, 其他玩家可以.
	此功能在 20130807 客戶端上測試有效, 更早之前的客戶端並未經過測試.

--------------------------------------------------------------

*getmapspawns "<地圖名稱>"{,<角色編號>};

用於獲取指定地圖的魔物刷新點信息.

地圖名稱:
	指定的地圖名稱, 比如 "prontera" 表示普隆德拉
	地圖名稱可以設置為 "this", 表示獲取當前腳本關聯玩家所在的地圖

角色編號:
	若指定了角色編號則使用 "this" 地圖名稱時將會查詢指定角色所在地圖的魔物刷新點信息
	此外 @ 變量的值也將綁定記錄到該角色身上

信息通過變量返回:
	@spawn_mobid[]		魔物編號 - 數值型數組
	@spawn_name$[]		魔物名稱 - 字符型數組
						使用 monster 指令的刷怪點可以設置魔物名稱,
						因此當若有指定特殊魔物名稱則優先返回特殊魔物名稱
	@spawn_num[]		刷新魔物數量 - 數值型數組
	@spawn_active[]		魔物當前激活數量 - 數值型數組
						當啟用 dynamic_mobs 時, 如果地圖沒有玩家存在則魔物不會被激活
	@spawn_size[]		魔物體型 - 數值型數組
						若為 -1 表示默認體型, 通常可能的返回值有:
							SZ_SMALL	-	表示小型
							SZ_MEDIUM	-	表示中型
							SZ_BIG		-	表示大型
	@spawn_isboss[]		魔物是否為 BOSS (可被 BOSS 雷達探測) - 數值型數組
							為 0 表示普通魔物, 為 1 表示 BOSS 魔物
	@spawn_delay1[]		魔物死亡後的固定刷新間隔 (單位為毫秒) - 數值型數組
	@spawn_delay2[]		額外的隨機浮動刷新間隔 (單位為毫秒) - 數值型數組
							若配置了 delay2 則魔物死亡後的刷新間隔為: delay1 ~ (delay1 + delay2) 之間的隨機毫秒數
	@spawn_ai[]			魔物的 AI 模式 - 數值型數組
						若為 -1 表示默認 AI 模式, 通常可能的返回值有:
							AI_NONE
							AI_ATTACK
							AI_SPHERE
							AI_FLORA
							AI_ZANZOU
							AI_LEGION
							AI_FAW
							AI_GUILD
	@spawn_level[]		魔物等級 - 數值型數組
							使用 monster 指令的刷怪點可以設置魔物等級,
							因此當若有指定特殊魔物等級則優先返回特殊魔物等級
	@spawn_eventname$[]	魔物死亡時觸發的事件標簽 - 字符型數組
							若為空字符串則表示沒有指定魔物死亡時觸發的事件標簽
	@spawn_mapid[]		魔物所在的地圖編號 (通常沒啥作用) - 數值型數組
	@spawn_mapname$[]	魔物所在的地圖名稱 - 字符型數組
	@spawn_x[]			魔物刷新點在地圖上的 x 坐標 - 數值型數組
	@spawn_y[]			魔物刷新點在地圖上的 y 坐標 - 數值型數組
	@spawn_xs[]			魔物刷新點在地圖上的 xs 坐標 (若為 -1 則表示沒有指定) - 數值型數組
	@spawn_ys[]			魔物刷新點在地圖上的 ys 坐標 (若為 -1 則表示沒有指定) - 數值型數組


	返回值及 @spawn_count 變量都會賦予查詢到的魔物刷怪點數量.

返回值:
	成功則返回找到的刷新點數量, 失敗則返回 -1

注意事項:
	返回值數組變量是 @ 開頭的角色變量.
	若指令在不關聯任何玩家的情況下被執行之後, 可以改用 $@ 變量來承接返回值.
	
	若您使用 $@ 變量來承接返回值內容的話,
	調用 getmapspawns 之後應該立刻使用變量的內容, 因為 $@ 變量是全服共享的, 
	如果調用完成後不立刻使用, 可能里面填充的內容就被其他玩家調用 getmapspawns 替換掉了.
	
	當使用 "this" 指令的時候, 若腳本不關聯任何玩家的話, 那麽必須指定 <角色編號>,
	否則地圖服務器將無法理解 "this" 具體是哪一張地圖.
	
	如果您希望列出一些菜單項讓玩家做選擇的話, 請使用 @ 變量承接.
	因為 @ 變量只保存在玩家角色身上, 不會被服務器其他玩家調用 getmapspawns 指令而覆蓋.
	
	與 getinventorylist 指令一樣, 請避免使用 getarraysize 來計算返回數組的長度,
	而是使用 @spawn_count 來作為返回數組中有效內容的最大數量, 否則可能會讀取到部分垃圾數據.

--------------------------------------------------------------

*getmobspawns <魔物編號>{,"<地圖名稱>"{,<角色編號>}};

用於查詢指定魔物在不同地圖的刷新點信息.

魔物編號:
	想查詢哪個魔物的刷新點信息, 就填寫該魔物的編號

地圖名稱:
	指定的地圖名稱, 比如 "prontera" 表示普隆德拉
	地圖名稱可以設置為 "this", 表示獲取當前腳本關聯玩家所在的地圖

角色編號:
	若指定了角色編號則使用 "this" 地圖名稱時將會查詢指定角色所在地圖的魔物刷新點信息
	此外 @ 變量的值也將綁定記錄到該角色身上

信息通過變量返回:
	@spawn_mobid[]		魔物編號 - 數值型數組
	@spawn_name$[]		魔物名稱 - 字符型數組
						使用 monster 指令的刷怪點可以設置魔物名稱,
						因此當若有指定特殊魔物名稱則優先返回特殊魔物名稱
	@spawn_num[]		刷新魔物數量 - 數值型數組
	@spawn_active[]		魔物當前激活數量 - 數值型數組
						當啟用 dynamic_mobs 時, 如果地圖沒有玩家存在則魔物不會被激活
	@spawn_size[]		魔物體型 - 數值型數組
						若為 -1 表示默認體型, 通常可能的返回值有:
							SZ_SMALL	-	表示小型
							SZ_MEDIUM	-	表示中型
							SZ_BIG		-	表示大型
	@spawn_isboss[]		魔物是否為 BOSS (可被 BOSS 雷達探測) - 數值型數組
							為 0 表示普通魔物, 為 1 表示 BOSS 魔物
	@spawn_delay1[]		魔物死亡後的固定刷新間隔 (單位為毫秒) - 數值型數組
	@spawn_delay2[]		額外的隨機浮動刷新間隔 (單位為毫秒) - 數值型數組
							若配置了 delay2 則魔物死亡後的刷新間隔為: delay1 ~ (delay1 + delay2) 之間的隨機毫秒數
	@spawn_ai[]			魔物的 AI 模式 - 數值型數組
						若為 -1 表示默認 AI 模式, 通常可能的返回值有:
							AI_NONE
							AI_ATTACK
							AI_SPHERE
							AI_FLORA
							AI_ZANZOU
							AI_LEGION
							AI_FAW
							AI_GUILD
	@spawn_level[]		魔物等級 - 數值型數組
							使用 monster 指令的刷怪點可以設置魔物等級,
							因此當若有指定特殊魔物等級則優先返回特殊魔物等級
	@spawn_eventname$[]	魔物死亡時觸發的事件標簽 - 字符型數組
							若為空字符串則表示沒有指定魔物死亡時觸發的事件標簽
	@spawn_mapid[]		魔物所在的地圖編號 (通常沒啥作用) - 數值型數組
	@spawn_mapname$[]	魔物所在的地圖名稱 - 字符型數組
	@spawn_x[]			魔物刷新點在地圖上的 x 坐標 - 數值型數組
	@spawn_y[]			魔物刷新點在地圖上的 y 坐標 - 數值型數組
	@spawn_xs[]			魔物刷新點在地圖上的 xs 坐標 (若為 -1 則表示沒有指定) - 數值型數組
	@spawn_ys[]			魔物刷新點在地圖上的 ys 坐標 (若為 -1 則表示沒有指定) - 數值型數組


	返回值及 @spawn_count 變量都會賦予查詢到的魔物刷怪點數量.

返回值:
	成功則返回找到的刷新點數量, 失敗則返回 -1

注意事項:
	返回值數組變量是 @ 開頭的角色變量.
	若指令在不關聯任何玩家的情況下被執行之後, 可以改用 $@ 變量來承接返回值.
	
	若您使用 $@ 變量來承接返回值內容的話,
	調用 getmobspawns 之後應該立刻使用變量的內容, 因為 $@ 變量是全服共享的, 
	如果調用完成後不立刻使用, 可能里面填充的內容就被其他玩家調用 getmobspawns 替換掉了.
	
	當使用 "this" 指令的時候, 若腳本不關聯任何玩家的話, 那麽必須指定 <角色編號>,
	否則地圖服務器將無法理解 "this" 具體是哪一張地圖.
	
	如果您希望列出一些菜單項讓玩家做選擇的話, 請使用 @ 變量承接.
	因為 @ 變量只保存在玩家角色身上, 不會被服務器其他玩家調用 getmobspawns 指令而覆蓋.

--------------------------------------------------------------

*getcalendartime <小時>,<分鐘>{,<月的第幾天>{,<周的第幾天>}};

獲取下次出現指定時間的 UNIX 時間戳

小時:
	可填寫值為 0 ~ 23 代表 24 小時

分鐘:
	可填寫值為 0 ~ 59 代表 60 分鐘

月的第幾天:
	可填寫值為 1 ~ 31 代表 31 天; 填寫 -1 則表示與月份無關

周的第幾天:
	SUNDAY - 周日
	MONDAY - 周一
	TUESDAY - 周二
	WEDNESDAY - 周三
	THURSDAY - 周四
	FRIDAY - 周五
	SATURDAY - 周六

如果只想使用 <每周的第幾天> 而不想使用 <每月的第幾天>,
那麽將 <每月的第幾天> 設為 -1 即可

返回值:
	成功則返回時間戳, 失敗則返回 -1

示例代碼:
	getcalendartime(19, 00); 				// 獲取下次 19:00 的時間戳
	getcalendartime(19, 00, 6); 			// 獲取下次 6 號 19:00 的時間戳
	getcalendartime(19, 10, -1, MONDAY);	// 獲取下次 周一 19:10 的時間戳

--------------------------------------------------------------

*getskillinfo <查詢的信息類型>,<技能編號>{,<技能等級>{,<角色編號>}};
*getskillinfo <查詢的信息類型>,<"技能名稱">{,<技能等級>{,<角色編號>}};

獲取指定技能在技能數據庫中所配置的各項信息

查詢的信息類型:
	SKI_CASTTYPE
		技能施法類型
		
		返回值為數值類型
		該字段的值來自 skill_db.yml 中提供的 TargetType 進行計算得出
		
		可能的返回值:
		----------------
		CAST_GROUND				/// 地面技能
		CAST_DAMAGE				/// 傷害技能
		CAST_NODAMAGE			/// 無傷害技能
		
	SKI_NAME
		技能名稱
		
		返回值為字符串類型
		該字段的值來自 skill_db.yml 中的 Name 字段
		通常技能名稱是英文常量, 比如狂擊的技能名稱是 SM_BASH
		
	SKI_DESCRIPTION
		技能描述
		
		返回值為字符串類型
		該字段的值來自 skill_db.yml 中的 Description 字段
		通常技能描述是遊戲里的技能名稱, 比如: 狂擊
		
	SKI_MAXLEVEL_IN_SKILLTREE
		指定職業的技能樹中該技能的最大等級
		
		返回值為數值類型
		需要在 <技能等級> 字段中傳入要查詢的職業代碼
		該字段的值來自 skill_tree.txt 中不同職業對被查詢技能所設置的最大技能等級
		
	SKI_SKILLTYPE
		技能傷害類型
		
		返回值為數值類型
		該字段的值來自 skill_db.yml 中的 Type 字段
		
		可能的返回值:
		----------------
		BF_WEAPON				/// 物理攻擊類型
		BF_MAGIC				/// 魔法攻擊類型
		BF_MISC					/// 其他類型
		
	SKI_HIT
		技能命中類型
		
		返回值為數值類型
		該字段的值來自 skill_db.yml 中的 Hit 字段
		
		可能的返回值:
		----------------
		DMG_SINGLE				/// (skill?)
		DMG_MULTI_HIT			/// multi-hit damage
		
	SKI_TARGETTYPE
		技能目標類型
		
		返回值為數值類型
		該字段的值來自 skill_db.yml 中的 TargetType 字段
		
		可能的返回值:
		----------------
		INF_PASSIVE_SKILL		/// 
		INF_ATTACK_SKILL		/// 
		INF_GROUND_SKILL		/// 
		INF_SELF_SKILL			/// 
		INF_SUPPORT_SKILL		///
		INF_TRAP_SKILL			///
		
	SKI_ELEMENT
		技能屬性
		
		返回值為數值類型
		需要在 <技能等級> 字段中傳入技能等級
		該字段的值來自 skill_db.yml 中的 Element 字段
		
		可能的返回值:
		----------------
		ELE_NEUTRAL				/// 無屬性 / 自然屬性
		ELE_WATER				/// 水屬性
		ELE_EARTH				/// 地屬性
		ELE_FIRE				/// 火屬性
		ELE_WIND				/// 風屬性
		ELE_POISON				/// 毒屬性
		ELE_HOLY				/// 聖屬性
		ELE_DARK				/// 暗屬性
		ELE_GHOST				/// 幽靈屬性
		ELE_UNDEAD				/// 不死屬性
		ELE_WEAPON				/// 使用武器的屬性
		ELE_ENDOWED				/// ??? 誰有了解的翻譯一下
		ELE_RANDOM				/// 隨機屬性
		
	SKI_DAMAGEFLAGS
		技能傷害的修正標記
		
		返回值為數值類型, 返回的是數組長度
		用於承接返回值的數組名稱為: @skill_damage_flags[]
		若在不關聯任何玩家的情況下執行, 則用於承接返回值的數組名稱為: $@skill_damage_flags[]
		該字段的值來自 skill_db.yml 中的 DamageFlags 字段
		
		返回值數組中保存是該技能激活的傷害修正標記
		
		可能的返回值:
		----------------
		NK_SPLASH				/// 
		NK_SPLASHSPLIT			/// 
		NK_IGNOREATKCARD		/// 
		NK_IGNOREELEMENT		/// 
		NK_IGNOREDEFENSE		/// 
		NK_IGNOREFLEE			/// 
		NK_IGNOREDEFCARD		/// 
		NK_CRITICAL				/// 
		NK_IGNORELONGCARD		/// 
		
	SKI_MAXLEVEL
		技能最大等級
		
		返回值為數值類型
		該字段的值來自 skill_db.yml 中的 MaxLevel 字段
		
	SKI_RANGE
		技能有效範圍 / 攻擊距離
		
		返回值為數值類型
		需要在 <技能等級> 字段中傳入技能等級
		該字段的值來自 skill_db.yml 中的 Range 字段
		
	SKI_SPLASHAREA
		技能濺射範圍
		
		返回值為數值類型
		需要在 <技能等級> 字段中傳入技能等級
		該字段的值來自 skill_db.yml 中的 SplashArea 字段
		
	SKI_HITCOUNT
		技能打擊段數
		
		返回值為數值類型
		需要在 <技能等級> 字段中傳入技能等級
		該字段的值來自 skill_db.yml 中的 HitCount 字段
		
	SKI_CASTTIME
		技能可變詠唱時間 (單位為毫秒)
		
		返回值為數值類型
		需要在 <技能等級> 字段中傳入技能等級
		該字段的值來自 skill_db.yml 中的 CastTime 字段
		
	SKI_FIXEDCASTTIME
		技能固定詠唱時間 (單位為毫秒)
		
		返回值為數值類型
		需要在 <技能等級> 字段中傳入技能等級
		該字段的值來自 skill_db.yml 中的 FixedCastTime 字段
		
		僅覆興後版本中擁有固定詠唱時間這個設定, 覆興前版本中該類查詢返回值強制為 -1
		
	SKI_AFTERCASTACTDELAY
		技能詠唱完畢後的動作延遲時間, 別名: 技能公共延遲 (單位為毫秒)
		
		返回值為數值類型
		需要在 <技能等級> 字段中傳入技能等級
		該字段的值來自 skill_db.yml 中的 AfterCastActDelay 字段
		
	SKI_AFTERCASTWALKDELAY
		技能詠唱完畢後的移動僵直時間, 別名: 技能攻擊僵直 (單位為毫秒)
		
		返回值為數值類型
		需要在 <技能等級> 字段中傳入技能等級
		該字段的值來自 skill_db.yml 中的 AfterCastWalkDelay 字段
		
	SKI_DURATION1
		技能時間配置字段 1 (單位為毫秒)
		
		返回值為數值類型
		需要在 <技能等級> 字段中傳入技能等級
		該字段的值來自 skill_db.yml 中的 Duration1 字段
		
		不同的技能對該字段的使用方式不同, 因此沒有明確的作用說明
		例如: 覆興後的 SM_ENDURE 技能在 Duration1 中配置的值被用作 "霸體" 的效果時長
		
	SKI_DURATION2
		技能時間配置字段 2 (單位為毫秒)
		
		返回值為數值類型
		需要在 <技能等級> 字段中傳入技能等級
		該字段的值來自 skill_db.yml 中的 Duration2 字段
		
		不同的技能對該字段的使用方式不同, 因此沒有明確的作用說明
		例如: 覆興後的 PR_LEXDIVINA 技能在 Duration2 中配置的值被用作 "沈默之術" 的效果時長
		
	SKI_CASTTIMEFLAGS
		技能詠唱時間的修正標記
		
		返回值為數值類型
		該字段的值來自 skill_db.yml 中的 CastTimeFlags 字段
		
		可能的返回值:
		----------------
		SKILL_CAST_IGNOREDEX		/// 標記位, 無視 DEX 帶來的修正影響
		SKILL_CAST_IGNORESTATUS		/// 標記位, 無視角色狀態 (StatusChange / 簡稱 SC) 的修正影響
		SKILL_CAST_IGNOREITEMBONUS	/// 標記位, 無視 bonus 效果調整器的修正影響
		
	SKI_CASTDELAYFLAGS
		技能延遲時間的修正標記
		
		返回值為數值類型
		該字段的值來自 skill_db.yml 中的 CastDelayFlags 字段
		
		可能的返回值:
		----------------
		SKILL_CAST_IGNOREDEX		/// 標記位, 無視 DEX 帶來的修正影響
		SKILL_CAST_IGNORESTATUS		/// 標記位, 無視角色狀態 (StatusChange / 簡稱 SC) 的修正影響
		SKILL_CAST_IGNOREITEMBONUS	/// 標記位, 無視 bonus 效果調整器的修正影響
		
	SKI_CASTDEFENSEREDUCTION
		技能在詠唱期間造成施法者的防禦降低倍率
		
		返回值為數值類型
		該字段的值來自 skill_db.yml 中的 CastDefenseReduction 字段
		
	SKI_FLAGS
		技能特殊標記
		
		返回值為數值類型, 返回的是數組長度
		用於承接返回值的數組名稱為: @skill_flags[]
		若在不關聯任何玩家的情況下執行, 則用於承接返回值的數組名稱為: $@skill_flags[]
		該字段的值來自 skill_db.yml 中的 Flags 字段
		
		返回值數組中保存是該技能的特殊標記
		
		可能的返回值:
		----------------
		INF2_ISQUEST				/// 這是任務技能
		INF2_ISNPC					/// 
		INF2_ISWEDDING				/// 這是結婚後才能擁有的技能
		INF2_ISSPIRIT				/// 
		INF2_ISGUILD				/// 這是公會技能
		INF2_ISSONG					/// 
		INF2_ISENSEMBLE				/// 
		INF2_ISTRAP					/// 這是陷阱技能
		INF2_TARGETSELF				/// 
		INF2_NOTARGETSELF			/// 
		INF2_PARTYONLY				/// 只能對隊伍中的成員使用
		INF2_GUILDONLY				/// 只能對公會中的成員使用
		INF2_NOTARGETENEMY			/// 
		INF2_ISAUTOSHADOWSPELL		/// 
		INF2_ISCHORUS				/// 
		INF2_IGNOREBGREDUCTION		/// 
		INF2_IGNOREGVGREDUCTION		/// 
		INF2_DISABLENEARNPC			/// 靠近部分 NPC 時禁止使用此技能
		INF2_TARGETTRAP				/// 
		INF2_IGNORELANDPROTECTOR	/// 
		INF2_ALLOWWHENHIDDEN		/// 
		INF2_ALLOWWHENPERFORMING	/// 
		INF2_TARGETEMPERIUM			/// 
		INF2_IGNOREKAGEHUMI			/// 
		INF2_ALTERRANGEVULTURE		/// 
		INF2_ALTERRANGESNAKEEYE		/// 
		INF2_ALTERRANGESHADOWJUMP	/// 
		INF2_ALTERRANGERADIUS		/// 
		INF2_ALTERRANGERESEARCHTRAP	/// 
		INF2_IGNOREHOVERING			/// 
		INF2_ALLOWONWARG			/// 
		INF2_ALLOWONMADO			/// 
		INF2_TARGETMANHOLE			/// 
		INF2_TARGETHIDDEN			/// 
		INF2_INCREASEDANCEWITHWUGDAMAGE		/// 
		INF2_IGNOREWUGBITE			/// 
		INF2_IGNOREAUTOGUARD		/// 
		INF2_IGNORECICADA			/// 
		INF2_SHOWSCALE				/// 
		
	SKI_CASTCANCEL
		技能在詠唱期間是否會被打斷
		
		返回值為數值類型
		該字段的值來自 skill_db.yml 中的 CastCancel 字段
		
	SKI_ACTIVEINSTANCE
		技能同時存在的個數上限, 通常作用於地面技能
		
		返回值為數值類型
		需要在 <技能等級> 字段中傳入技能等級
		該字段的值來自 skill_db.yml 中的 ActiveInstance 字段
		
	SKI_KNOCKBACK
		技能擊退距離
		
		返回值為數值類型
		需要在 <技能等級> 字段中傳入技能等級
		該字段的值來自 skill_db.yml 中的 Knockback 字段
		
	SKI_COOLDOWN
		技能可以被再次使用的冷卻時間 (單位為毫秒)
		
		返回值為數值類型
		需要在 <技能等級> 字段中傳入技能等級
		該字段的值來自 skill_db.yml 中的 Cooldown 字段
		
	SKI_NONEARNPC_TYPE
		技能不可在哪些 NPC 附近使用
		
		返回值為數值類型
		該字段的值來自 skill_db.yml 中的 NoNearNPC 節點的 Type 字段
		
		該選項的兩種情況生效:
			當 Flags 中設定了 DisableNearNpc 時生效
			當 Unit->Flag 中設定了 NoFootSet 時生效
		
		可能的返回值:
		----------------
		SKILL_NONEAR_WARPPORTAL		/// 標記位, 不能靠近傳送點附近
		SKILL_NONEAR_SHOP			/// 標記位, 不能靠近商店附近
		SKILL_NONEAR_NPC			/// 標記位, 不能靠近 NPC 附近
		SKILL_NONEAR_TOMB			/// 標記位, 不能靠近 MVP 墳墓附近
		
	SKI_NONEARNPC_ADDITIONALRANGE
		技能不可靠近的 NPC 額外距離要求
		
		返回值為數值類型
		該字段的值來自 skill_db.yml 中的 NoNearNPC 節點的 AdditionalRange 字段
		
	SKI_COPYFLAGS_SKILL
		技能是否能被覆制
		
		返回值為數值類型
		該字段的值來自 skill_db.yml 中的 CopyFlags 節點的 Skill 字段
		
		可能的返回值:
		----------------
		0							/// 不可被覆制
		SKILL_COPY_PLAGIARISM		/// 標記位, 可以被"抄襲"技能 (RG_PLAGIARISM) 覆制
		SKILL_COPY_REPRODUCE		/// 標記位, 可以被"覆制"技能 (SC_REPRODUCE) 覆制
		
	SKI_COPYFLAGS_REMOVEREQUIREMENT
		技能被覆制後, 抄襲者進行施法時是否忽略部分條件
		
		返回值為數值類型
		該字段的值來自 skill_db.yml 中的 CopyFlags 節點的 RemoveRequirement 字段
		
		可能的返回值:
		----------------
		SKILL_REQ_HPCOST			/// 標記位, 無需扣減指定點數的 HP
		SKILL_REQ_SPCOST			/// 標記位, 無需扣減指定點數的 SP
		SKILL_REQ_HPRATECOST		/// 標記位, 無需扣減指定百分比的 HP
		SKILL_REQ_SPRATECOST		/// 標記位, 無需扣減指定百分比的 SP
		SKILL_REQ_MAXHPTRIGGER		/// 標記位, 無需檢查至少要有百分之多少 HP 才能施法
		SKILL_REQ_ZENYCOST			/// 標記位, 無需扣減指定數量的 Zeny
		SKILL_REQ_WEAPON			/// 標記位, 無需檢查武器符合特定類型
		SKILL_REQ_AMMO				/// 標記位, 無需檢查彈藥符合特定類型
		SKILL_REQ_STATE				/// 標記位, 無需檢查場景類型
		SKILL_REQ_STATUS			/// 標記位, 無需檢查角色狀態類型
		SKILL_REQ_SPIRITSPHERECOST	/// 標記位, 無需檢查靈氣彈數量
		SKILL_REQ_ITEMCOST			/// 標記位, 無需檢查特定物品消耗品
		SKILL_REQ_EQUIPMENT			/// 標記位, 無需檢查是否穿戴特定裝備
		
	SKI_UNIT_ID
		技能綁定的首選 Unit 子單位編號
		
		返回值為數值類型
		該字段的值來自 skill_db.yml 中的 Unit 節點的 Id 字段
		
	SKI_UNIT_ALTERNATEID
		技能綁定的備選 Unit 子單位編號
		
		返回值為數值類型
		該字段的值來自 skill_db.yml 中的 Unit 節點的 AlternateId 字段
		
	SKI_UNIT_LAYOUT
		技能綁定的 Unit 子單位布局
		
		返回值為數值類型
		需要在 <技能等級> 字段中傳入技能等級
		該字段的值來自 skill_db.yml 中的 Unit 節點的 Layout 字段
		
	SKI_UNIT_RANGE
		技能綁定的 Unit 子單位作用距離
		
		返回值為數值類型
		需要在 <技能等級> 字段中傳入技能等級
		該字段的值來自 skill_db.yml 中的 Unit 節點的 Range 字段
		
	SKI_UNIT_INTERVAL
		技能綁定的 Unit 子單位間隔時間 (單位為毫秒)
		
		返回值為數值類型
		該字段的值來自 skill_db.yml 中的 Unit 節點的 Interval 字段
		
	SKI_UNIT_TARGET
		技能綁定的 Unit 子單位作用目標
		
		返回值為數值類型
		該字段的值來自 skill_db.yml 中的 Unit 節點的 Target 字段
		
		可能的返回值:
		----------------
		BCT_SELF					/// 自己
		BCT_ENEMY					/// 敵人
		BCT_PARTY					/// 隊伍成員
		BCT_GUILDALLY				/// 同盟成員, 不含公會成員
		BCT_NEUTRAL					/// 自然目標
		BCT_SAMEGUILD				/// 公會成員, 不含同盟成員
		
	SKI_UNIT_FLAG
		技能綁定的 Unit 子單位特殊標記
		
		返回值為數值類型, 返回的是數組長度
		用於承接返回值的數組名稱為: @skill_unit_flag[]
		若在不關聯任何玩家的情況下執行, 則用於承接返回值的數組名稱為: $@skill_unit_flag[]
		該字段的值來自 skill_db.yml 中的 Unit 節點的 Flag 字段
		
		可能的返回值:
		----------------
		UF_NOENEMY					/// If 'defunit_not_enemy' is set, the target is changed to 'friend'
		UF_NOREITERATION			/// Spell cannot be stacked
		UF_NOFOOTSET				/// Spell cannot be cast near/on targets
		UF_NOOVERLAP				/// Spell effects do not overlap
		UF_PATHCHECK				/// Only cells with a shootable path will be placed
		UF_NOPC						/// May not target players
		UF_NOMOB					/// May not target mobs
		UF_SKILL					/// May target skills
		UF_DANCE					/// Dance
		UF_ENSEMBLE					/// Duet
		UF_SONG						/// Song
		UF_DUALMODE					/// Spells should trigger both ontimer and onplace/onout/onleft effects.
		UF_NOKNOCKBACK				/// Skill unit cannot be knocked back
		UF_RANGEDSINGLEUNIT			/// hack for ranged layout, only display center
		UF_CRAZYWEEDIMMUNE			/// Immune to Crazy Weed removal
		UF_REMOVEDBYFIRERAIN		/// removed by Fire Rain
		UF_KNOCKBACKGROUP			/// knockback skill unit with its group instead of single unit
		UF_HIDDENTRAP				/// Hidden trap [Cydh]
		
	SKI_REQUIRES_HPCOST
		技能施法條件 - 需要扣減多少點 HP 才能施法
		
		返回值為數值類型
		需要在 <技能等級> 字段中傳入技能等級
		該字段的值來自 skill_db.yml 中的 Requires 節點的 HpCost 字段
		
	SKI_REQUIRES_SPCOST
		技能施法條件 - 需要扣減多少點 SP 才能施法
		
		返回值為數值類型
		需要在 <技能等級> 字段中傳入技能等級
		該字段的值來自 skill_db.yml 中的 Requires 節點的 SpCost 字段
		
	SKI_REQUIRES_MAXHPTRIGGER
		技能施法條件 - 需要至少剩余百分之多少的 HP 才能施法
		
		返回值為數值類型
		需要在 <技能等級> 字段中傳入技能等級
		該字段的值來自 skill_db.yml 中的 Requires 節點的 MaxHpTrigger 字段
		
	SKI_REQUIRES_HPRATECOST
		技能施法條件 - 需要扣減百分之多少的 HP 才能施法
		
		返回值為數值類型
		需要在 <技能等級> 字段中傳入技能等級
		該字段的值來自 skill_db.yml 中的 Requires 節點的 HpRateCost 字段
		
	SKI_REQUIRES_SPRATECOST
		技能施法條件 - 需要扣減百分之多少的 SP 才能施法
		
		返回值為數值類型
		需要在 <技能等級> 字段中傳入技能等級
		該字段的值來自 skill_db.yml 中的 Requires 節點的 SpRateCost 字段
		
	SKI_REQUIRES_ZENYCOST
		技能施法條件 - 需要扣減多少 Zeny 才能施法
		
		返回值為數值類型
		需要在 <技能等級> 字段中傳入技能等級
		該字段的值來自 skill_db.yml 中的 Requires 節點的 ZenyCost 字段
		
	SKI_REQUIRES_WEAPON
		技能施法條件 - 至少需要裝備符合任意一個類型的武器才能施法
		
		返回值為數值類型
		需要在 <技能等級> 字段中傳入技能等級
		該字段的值來自 skill_db.yml 中的 Requires 節點的 Weapon 字段
		
		可能的返回值:
		----------------
		0							/// 任何武器
		W_DAGGER					/// 短劍
		W_1HSWORD					/// 單手劍
		W_2HSWORD					/// 雙手劍
		W_1HSPEAR					/// 單手矛/槍/戟
		W_2HSPEAR					/// 雙手矛/槍/戟
		W_1HAXE						/// 單手斧
		W_2HAXE						/// 雙手斧
		W_MACE						/// 單手鈍器
		W_2HMACE					/// 雙手鈍器
		W_STAFF						/// 單手杖
		W_2HSTAFF					/// 雙手杖
		W_BOW						/// 弓
		W_KNUCKLE					/// 拳套
		W_MUSICAL					/// 樂器
		W_WHIP						/// 鞭子
		W_BOOK						/// 書
		W_KATAR						/// 拳刃
		W_REVOLVER					/// 左輪手槍
		W_RIFLE						/// 來覆槍
		W_GATLING					/// 格林機關槍
		W_SHOTGUN					/// 散彈槍
		W_GRENADE					/// 榴彈槍
		W_HUUMA						/// 風魔
		MAX_WEAPON_TYPE				/// 該值減去 1 等於最大的武器類型值 (遍歷用)
		
		例子:
		----------------
		(返回值 & (1 << W_DAGGER)) == (1 << W_DAGGER) 成立則表示穿戴短劍才能施法
		
	SKI_REQUIRES_AMMO
		技能施法條件 - 需要裝備哪種類型的彈藥才能施法
		
		返回值為數值類型
		需要在 <技能等級> 字段中傳入技能等級
		該字段的值來自 skill_db.yml 中的 Requires 節點的 Ammo 字段
		
		可能的返回值:
		----------------
		0							/// 任何彈藥
		AMMO_ARROW					/// 箭矢
		AMMO_DAGGER					/// 短刀
		AMMO_BULLET					/// 子彈
		AMMO_SHELL					/// 炮彈
		AMMO_GRENADE				/// 榴彈
		AMMO_SHURIKEN				/// 手里劍
		AMMO_KUNAI					/// 苦無
		AMMO_CANNONBALL				/// 加農炮彈
		AMMO_THROWWEAPON			/// 投擲物品
		MAX_AMMO_TYPE				/// 該值減去 1 等於最大的彈藥類型值 (遍歷用)
		
		例子:
		----------------
		(返回值 & (1 << AMMO_ARROW)) == (1 << AMMO_ARROW) 成立則表示使用箭矢作為彈藥才能施法
		
	SKI_REQUIRES_AMMOAMOUNT
		技能施法條件 - 需要多少個指定的彈藥才能施法
		
		返回值為數值類型
		需要在 <技能等級> 字段中傳入技能等級
		該字段的值來自 skill_db.yml 中的 Requires 節點的 AmmoAmount 字段
		
	SKI_REQUIRES_STATE
		技能施法條件 - 必須在哪些特殊的環境狀態下才能施法
		
		返回值為數值類型
		該字段的值來自 skill_db.yml 中的 Requires 節點的 State 字段
		
		可能的返回值:
		----------------
		ST_NONE,					/// 
		ST_HIDDEN,					/// 
		ST_RIDING,					/// 乘騎狀態
		ST_FALCON,					/// 獵鷹狀態
		ST_CART,					/// 有手推車狀態
		ST_SHIELD,					/// 
		ST_RECOVER_WEIGHT_RATE,		/// 
		ST_MOVE_ENABLE,				/// 
		ST_WATER,					/// 站在水面上
		ST_RIDINGDRAGON,			/// 
		ST_WUG,						/// 
		ST_RIDINGWUG,				/// 
		ST_MADO,					/// 魔導機甲狀態
		ST_ELEMENTALSPIRIT,			/// 
		ST_ELEMENTALSPIRIT2,		/// 
		ST_PECO,					/// 
		ST_SUNSTANCE,				/// 
		ST_MOONSTANCE,				/// 
		ST_STARSTANCE,				/// 
		ST_UNIVERSESTANCE			/// 
		
	SKI_REQUIRES_STATUS
		技能施法條件 - 必須在哪些特殊的角色狀態下才能施法
		
		返回值為數值類型, 返回的是數組長度
		用於承接返回值的數組名稱為: @skill_requires_status[]
		若在不關聯任何玩家的情況下執行, 則用於承接返回值的數組名稱為: $@skill_requires_status[]
		該字段的值來自 skill_db.yml 中的 Requires 節點的 Status 字段
		
		返回值數組中保存是角色狀態編號
		備注: StatusChange / 簡稱 SC / 就是用 sc_start 可以啟動的那些狀態
		
		例子:
		----------------
		.@len = getskillinfo(SKI_REQUIRES_STATUS,"MO_EXTREMITYFIST");
		dispbottom "MO_EXTREMITYFIST 要求角色有以下編號的狀態才能使用:";
		for (.@i = 0; .@i < .@len; .@i++) {
			dispbottom sprintf("第 %d 個狀態: 狀態編號 %d", .@i, @skill_requires_status[.@i]);
		}
		
	SKI_REQUIRES_SPHERECOST
		技能施法條件 - 必須擁有多少個靈氣彈才能施法
		
		返回值為數值類型
		需要在 <技能等級> 字段中傳入技能等級
		該字段的值來自 skill_db.yml 中的 Requires 節點的 SphereCost 字段
		
	SKI_REQUIRES_ITEMCOST
		技能施法條件 - 至少持有特定全部物品道具才能施法
		
		返回值為數值類型, 返回的是數組長度
		用於承接返回值的數組共有兩個:
			@skill_requires_itemid[]	保存道具編號
			@skill_requires_amount[]	保存所需的道具數量
		若在不關聯任何玩家的情況下執行, 則用於承接返回值的兩個數組名稱為:
			$@skill_requires_itemid[]	保存道具編號
			$@skill_requires_amount[]	保存所需的道具數量
		該字段的值來自 skill_db.yml 中的 Requires 節點的 ItemCost 字段
		
		例子:
		----------------
		.@len = getskillinfo(SKI_REQUIRES_ITEMCOST,"KO_MAKIBISHI");
		dispbottom "KO_MAKIBISHI 要求身上有[以下全部]道具才能使用:";
		for (.@i = 0; .@i < .@len; .@i++) {
			dispbottom sprintf("第 %d 個道具: 物品編號 %d x %d 個", .@i, @skill_requires_itemid[.@i], @skill_requires_amount[.@i]);
		}
		
	SKI_REQUIRES_EQUIPMENT
		技能施法條件 - 至少需要裝備任意一件特定道具才能施法
		
		返回值為數值類型, 返回的是數組長度
		用於承接返回值的數組名稱為: @skill_requires_equipment[]
		若在不關聯任何玩家的情況下執行, 則用於承接返回值的數組名稱為: $@skill_requires_equipment[]
		該字段的值來自 skill_db.yml 中的 Requires 節點的 Equipment 字段
		
		返回值數組中保存是裝備的道具編號
		
		例子:
		----------------
		.@len = getskillinfo(SKI_REQUIRES_EQUIPMENT,"RL_P_ALTER");
		dispbottom "RL_P_ALTER 要求穿戴[以下任意一件]裝備才能使用:";
		for (.@i = 0; .@i < .@len; .@i++) {
			dispbottom sprintf("第 %d 件裝備: 物品編號 %d", .@i, @skill_requires_equipment[.@i]);
		}
		
技能編號:
	傳入需要查詢的技能編號 (定義在 skill_db 中每個技能的 Id 字段)
	例如: 劍士狂擊技能的技能編號是 5

技能名稱:
	傳入需要查詢的技能名稱 (定義在 skill_db 中每個技能的 Name 字段)
	例如: 劍士狂擊技能的名稱是 SM_BASH (字符串類型)

技能等級:
	在絕大多數情況下這個參數用來填寫要查詢的技能等級
	部分查詢類型中 <技能等級> 可能會被用作傳遞其他信息, 例如: SKI_MAXLEVEL_IN_SKILLTREE

返回值:
	根據 <查詢的信息類型> 的不同, 返回值的含義會有差異
	具體返回值細節已經在上文中每個不同的 <查詢的信息類型> 說明中定義
	
	若傳遞的 <查詢的信息類型>,<技能編號>,<"技能名稱"> 無效, 則將報錯並返回 -1

--------------------------------------------------------------

*boss_monster "<地圖名>",<x坐標>,<y坐標>,"<顯示名稱>",<魔物編號>,<召喚數量>{,"<死亡事件標簽>",<體型大小>,<AI>};
*boss_monster "<地圖名>",<x坐標>,<y坐標>,"<顯示名稱>","<魔物名稱>",<召喚數量>{,"<死亡事件標簽>",<體型大小>,<AI>};

召喚魔物並使之能被 BOSS 雷達探測 (哪怕被召喚魔物本身不是 BOSS) [人魚姬的思念]
各參數的詳細說明請直接參考 doc/script_commands.txt 中 monster 的說明.

顯示名稱:
	是指魔物被召喚出來時顯示的名字, 可以隨便起名.

魔物名稱:
	是指魔物在 mob_db 中的 AegisName

提示信息:
	用來記錄新創造的魔物遊戲單位編號的 $@mobid[] 數組, 在此也有作用.

--------------------------------------------------------------

*sleep3 <休眠毫秒數>;

休眠一段時間再執行後續腳本, 與 sleep2 類似但忽略報錯 [人魚姬的思念]

休眠毫秒數:
	期望腳本休眠多長時間 (單位為毫秒)

返回值:
	該指令無論成功與否, 都不會有返回值

注意事項:
	執行該指令時若腳本沒有關聯玩家, 則效果等同於 sleep.
	關聯玩家情況下若執行該指令後玩家下線, 那麽休眠結束後腳本將立刻結束 (不會繼續往下執行).

--------------------------------------------------------------

*getquesttime <任務編號>{,<想查詢的時間類型>{,<角色編號>}};

查詢角色指定任務的時間信息.

任務編號:
	定義在 quest_db.yml 的任務 Id 值

想查詢的時間類型:
	0	-	任務的到期時間的 Unix 時間戳 (默認值)
	1	-	任務的開始時間的 Unix 時間戳
	2	-	任務的剩余時間秒數

返回值:
	成功返回時間戳, 失敗返回 -1

注意事項:
	任務開始時間會受到 quest_db.yml 中任務時長配置的影響,
	在任務系統中唯一準確的是任務的過期時間,
	任務的開始時間是用過期時間減去 quest_db.yml 中任務時長計算出來的.
	
	任務的剩余時間秒數的最小值為 0, 為 0 可視為任務已過期.

--------------------------------------------------------------

*query_sql_async("您的 SQL 查詢語句"{, <用於保存第 1 列的數組變量>{, <用於保存第 2 列的數組變量>{, ...}}});
*query_logsql_async("您的 SQL 查詢語句"{, <用於保存第 1 列的數組變量>{, <用於保存第 2 列的數組變量>{, ...}}});

這組腳本指令來自與 rAthena 社區一位名為 inhyositsu 的貢獻者.
對應在 rAthena 社區的 Pull Request 地址為: https://github.com/rathena/rathena/pull/5624

以 *_async 結尾的這一組 query 指令將會以異步的方式執行,
這意味著查詢過程中將不會阻塞腳本線程 (更重要的是不會阻塞整個地圖服務器).

如果您發起一個 SQL 查詢而不攜帶其他用來保存返回值的參數 (例如: Insert 語句),
那麽不管 Insert 過程多麽耗時腳本都將立刻往下執行, 而不用卡在那里等.

如果你發起了一個類似 SELECT 並且希望獲取他返回值數據的請求,
那麽腳本將會進入休眠狀態 (類似 sleep 指令的效果) 並且等待查詢完成後再喚醒腳本繼續執行.

注意事項:
	多個 *_async 指令的查詢請求是串行的 (異步不等於並行), 他不會卡死地圖服務器,
	就用戶可能需要等待更長時間才能得到腳本的響應.
	
	例如: 現在您設計了一個覆雜的 SQL 查詢, 它的查詢會耗時 5 秒. 
	那麽如果全服 100 個玩家[同時]都去執行這個腳本的話, 這 100 個玩家不會卡死,
	剩下的其他在線玩家也能正常遊戲, 
	但服務器內部將需要總共 500 秒來完成這 100 個玩家的查詢請求.
	最差最差的情況下, 最後的那個玩家等到腳本被喚醒繼續執行, 需要等待 500 秒.
	
使用提示:
	這並不是一個值得提倡使用的指令, 站在遊戲體驗的角度考慮,
	您依然應該盡可能的不要讓玩家有等待的機會.
	這個指令推薦用在一些與玩家無關的定時執行任務, 舉個不恰當的例子比如:
	
		每天淩晨 04:00 整時查詢 picklog 表看看今天撿取道具最多的玩家是誰,
		把它記下來給個稱號: 蘇乞兒
	
	之所以稱之為不恰當, 是因為你可能有其他性能更優的做法來達成類似的目的.
	
	其次執行的查詢要盡量避免鎖表, 比如剛剛的需求如果換成:
	
		每天淩晨 04:00 整時將 picklog 表中 7 天以前的記錄直接刪除掉.
	
	那他就是危險的, 因為在刪除 picklog 表的記錄時, 數據庫會鎖定 picklog 表,
	這會導致其他正常需要往這個表插入數據的查詢, 被阻塞住.
	
	上面只是舉例, 服務端對日志表的寫入使用了 INSERT DELAYED 語法,
	可能影響不大 (未考證).
	
三級強悍的注意事項:
	能不用就不用, 用的話要知道自己在什麽, 以及可能導致的一些潛在問題.
	我僅代表個人, 主張不應該在地圖服務器出於任何目的地執行覆雜的、長耗時的 SQL 查詢,
	危險程度僅次於焊雷管鋸燈泡...

--------------------------------------------------------------

*unitspecialeffect <遊戲單位編號>,<特效編號>{,<誰能看見特效>{,<能看見特效的賬號編號>}};

使指定遊戲單位可以顯示某個特效, 類似於 specialeffect 不過它可以控制僅顯示給指定範圍的玩家目標

遊戲單位編號:
	希望給哪個遊戲單位顯示出特效, 可以是魔物、NPC、生命體、玩家等等
	只需要傳遞他們的遊戲單位編號即可

特效編號:
	遊戲特效的 Effect 編號, 可在遊戲中使用 @effect 指令來確認特效編號的視覺效果

誰能看見特效:
	用來控制特效的可見範圍, 或者說這個單位的特效應該顯示給什麽範圍的玩家

	AREA		-	發送給可視範圍內的玩家 (默認)
	SELF		-	發送給自己
					如果指定 <能看見特效的賬號編號> 則特效只有指定玩家看到
	PARTY_AREA	- 	發送給以 <遊戲單位編號> 為中心可視範圍內的隊伍成員
	GUILD_AREA	- 	發送給以 <遊戲單位編號> 為中心可視範圍內的公會成員
	BG_AREA		- 	發送給以 <遊戲單位編號> 為中心可視範圍內的戰場陣營成員

能看見特效的賬號編號:
	當 <誰能看見特效> 等於 SELF 的時候
	可以通過此參數指定一個玩家賬號編號, 確保只有他才能看到這個特效

返回值:
	該指令無論成功與否, 都不會有返回值

注意事項:
	只有當 <遊戲單位編號> 指定的是一個玩家時, <誰能看見特效> 為 PARTY_AREA, 
	GUILD_AREA, BG_AREA 這幾個選項才會有效. 否則程序無法判斷出應該給什麽隊伍,
	公會, 戰場陣營的成員來發送特效.

--------------------------------------------------------------

*next_dropitem_special <道具綁定類型>,<租賃時長>,<掉落光柱顏色>;

對下一個掉落到地面上的物品進行特殊設置, 支持魔物掉落道具和 makeitem 系列指令

道具綁定類型:
	-1              -   不進行特殊設置
	Bound_None      -   沒有綁定 (與 0 等價, 但更推薦用常量)
	Bound_Account   -   綁定賬號的道具, 可放個人倉庫, 全賬號共享
	Bound_Guild     -   綁定公會的道具, 可放公會倉庫與他人共享, 擁有物品的人離開公會後物品消失
	Bound_Party     -   綁定隊伍的道具, 離開隊伍後消失
	Bound_Char      -   綁定角色的道具, 不能放個人倉庫

租賃時長:
	從道具掉落時刻起開始計時, 當達到 <租賃時長> 指定的秒數之後道具將從背包被移除
	單位為秒, 若該值非 0 則道具將會被視為租賃道具

掉落光柱顏色:
	物品掉落光柱需要客戶端版本大於等於 20180418 才支持, 舊版本客戶端沒有光柱

	-1                          -   不進行特殊設置
	DROPEFFECT_CLIENT           -   使用客戶端的物品光柱配置
	DROPEFFECT_BLUE_PILLAR      -   藍色光柱
	DROPEFFECT_YELLOW_PILLAR    -   黃色光柱
	DROPEFFECT_PURPLE_PILLAR    -   紫色光柱
	DROPEFFECT_GREEN_PILLAR     -   綠色光柱, 在 20200304 之前會變成橙色光柱
	DROPEFFECT_RED_PILLAR       -   紅色光柱

	DROPEFFECT_WHITE_PILLAR     -   白色光柱, 20200304 之後被取消
	DROPEFFECT_ORANGE_PILLAR    -   橙色光柱, 20200304 之後被綠色光柱替換

返回值:
	該指令無論成功與否, 都不會有返回值

注意事項:
	<掉落光環顏色> 的優先級高於 makeitem 系列指令的 <canShowEffect> 字段設置

	若希望對 makeitem / makeitem2 / makeitem3 生效, 那麽請在使用這些 makeitem 指令
	之前, 緊挨著使用 next_dropitem_special, 例如:

	next_dropitem_special -1,0,DROPEFFECT_BLUE_PILLAR;
	getmapxy(.@mapname$, .@mapx, .@mapy);
	makeitem 501,1,.@mapname$,.@mapx,.@mapy;

--------------------------------------------------------------

*getgradeitem <物品編號>,<創造數量>,<是否已鑒定>,<精煉值>,<屬性>,<第一卡槽>,<第二卡槽>,<第三卡槽>,<第四卡槽>,<裝備的附魔評級>,<隨機屬性的編號數組>,<隨機屬性的值數組>,<隨機屬性的參數數組>{,<賬號編號>};
*getgradeitem "<物品名稱>",<創造數量>,<是否已鑒定>,<精煉值>,<屬性>,<第一卡槽>,<第二卡槽>,<第三卡槽>,<第四卡槽>,<裝備的附魔評級>,<隨機屬性的編號數組>,<隨機屬性的值數組>,<隨機屬性的參數數組>{,<賬號編號>};

創造帶有指定附魔評級的道具, 與 getitem4 腳本指令完全等價.

裝備的附魔評級:
	ENCHANTGRADE_NONE	表示沒有評級
	ENCHANTGRADE_D		表示評級為 D
	ENCHANTGRADE_C		表示評級為 C
	ENCHANTGRADE_B		表示評級為 B
	ENCHANTGRADE_A		表示評級為 A

提示信息:
	從 v1.1.17 開始 rAthena 已經實現了 getitem4 指令,
	因此 getgradeitem 降級為 getitem4 的別名, 為了腳本通用性請盡量使用 getitem4.

--------------------------------------------------------------

*getrateidx <數值型數組變量>;
*getrateidx <數值1>{, <數值2>{, ...<數值n>}};

隨機獲取一個數值型數組的索引序號,
數組中每個元素的值為權重值, 權重越高命中機率越大.

數值型數組變量:
	存放著權重值的數值型數組變量, 例如下面這個:
	setarray .@rate[0],2,6,3,5;

返回值:
	成功則返回隨機命中的索引序號, 失敗則保存並中斷腳本的執行
	索引序號將從 0 開始計算, 第一個元素為 0, 第二個元素為 1 以此類推...

用法演示:
	setarray .@item[0],501,502,503,504;
	setarray .@rate[0],2,6,3,5;
	getitem .@item[getrateidx(.@rate)],1;
	
	有 2 / (2+6+3+5) = 0.125  * 100 = 12.50% 的機率獲得紅色藥水 (501)
	有 6 / (2+6+3+5) = 0.375  * 100 = 37.50% 的機率獲得赤色藥水 (502)
	有 3 / (2+6+3+5) = 0.1875 * 100 = 18.75% 的機率獲得黃色藥水 (503)
	有 5 / (2+6+3+5) = 0.3125 * 100 = 31.25% 的機率獲得白色藥水 (504)

注意事項:
	數組中若有某個索引的值為 0, 那麽該索引將永遠不會被命中.

--------------------------------------------------------------

*whodropitem <物品編號/"物品名稱">{,<返回的最大記錄數>{,<角色編號>}};

查詢指定道具會從哪些魔物身上掉落以及掉落的機率信息, 與 @whodrops 管理員指令類似.
查詢後將返回按掉率降序排列的結果數組, 結果會與 whodrops 略有差異.

物品編號/"物品名稱":
	多類型參數. 可以填寫數值類型的道具編號, 或者字符串類型的道具名稱.
	推薦使用道具編號, 相較而言結果會更加準確.

返回的最大記錄數:
	可選參數, 若不指定此參數則默認返回最多 MAX_SEARCH 條記錄 (通常為 5 條記錄)
	如果選擇填寫的話, 可填寫的有效區間為 1 - 500 條記錄

信息通過變量返回:
	@whodropitem_mob_id[]			魔物編號 - 數值型數組
	@whodropitem_mob_jname$[]		魔物名稱 - 字符型數組
									對應 mob_db 魔物數據庫中 JapaneseName 字段的值
	@whodropitem_chance[]			掉落被查詢道具的機率 - 數值型數組
									有效區間為 0 - 10000, 若為 10000 則表示 100% 掉落
	@whodropitem_count				本次查詢返回的記錄數 - 數值型變量

返回值:
	返回本次查詢返回的記錄數, 與 @whodropitem_count 等價

用法演示:
	whodropitem(512, 15);	// 查詢掉落 "蘋果" 機率最高的前 15 個魔物
	for (.@i = 0; .@i < @whodropitem_count; .@i++) {
		dispbottom(sprintf("第 %02d 條記錄 : 編號為 %d 的魔物 [%s] 掉落道具的機率為: %d", .@i + 1, @whodropitem_mob_id[.@i], @whodropitem_mob_jname$[.@i], @whodropitem_chance[.@i]));
	}

注意事項:
	返回值數組變量是 @ 開頭的角色變量.
	若指令在不關聯任何玩家的情況下被執行之後, 可以改用 $@ 變量來承接返回值.
	
	若您使用 $@ 變量來承接返回值內容的話,
	調用 whodropitem 之後應該立刻使用變量的內容, 因為 $@ 變量是全服共享的, 
	如果調用完成後不立刻使用, 可能里面填充的內容就被其他玩家調用 whodropitem 替換掉了.
	
	如果您希望列出一些菜單項讓玩家做選擇的話, 請使用 @ 變量承接.
	因為 @ 變量只保存在玩家角色身上, 不會被服務器其他玩家調用 whodropitem 指令而覆蓋.
	
	與 getinventorylist 指令一樣, 請避免使用 getarraysize 來計算返回數組的長度,
	而是使用 @whodropitem_count 來作為返回數組中有效內容的最大數量, 否則可能會讀取到部分垃圾數據.
	
	返回的掉率將會參考等級懲罰、VIP 會員加成等結果;
	若希望排除這部分影響, 可以在不關聯玩家的情況下執行該指令.

--------------------------------------------------------------

*getbossinfo {<"地圖名稱">{,<魔物編號>{,<角色編號>}}};

查詢 BOSS 魔物重生時間及其墳墓等信息

地圖名稱:
	指定的地圖名稱, 比如 "prontera" 表示普隆德拉
	地圖名稱可以設置為 "this", 表示獲取當前腳本關聯玩家所在的地圖
	地圖名稱可以設置為 "all", 表示獲取全服地圖

魔物編號:
	查詢特定魔物編號的 BOSS 魔物信息

角色編號:
	若指定了角色編號則使用 "this" 地圖名稱時將會查詢指定角色所在地圖的魔物刷新點信息
	此外 @ 變量的值也將綁定記錄到該角色身上

返回值:
	返回查詢到的記錄數, 查詢失敗或查無記錄則返回 0


信息通過變量返回:
	@boss_mapid[]				BOSS 魔物所在的地圖編號 (通常沒啥作用) - 數值型數組
	@boss_mapname$[]			BOSS 魔物所在的地圖名稱 - 字符型數組
	@boss_x[]					BOSS 魔物所在的 x 坐標 - 數值型數組
	@boss_y[]					BOSS 魔物所在的 y 坐標 - 數值型數組
		
	@boss_gid[]					BOSS 魔物的遊戲單位編號 - 數值型數組
								注意: 在Giraffe<模擬器>中, 魔物重生時候的遊戲單位編號可能會變化
	@boss_spawn[]				BOSS 魔物將在多少毫秒之後刷新覆活 - 數值型數組
								若為 0 則表示現在目標存活
	@boss_classid[]				BOSS 魔物的魔物編號 - 數值型數組
		
	@boss_tomb_mapid[]			BOSS 墓碑所在的地圖編號 (通常沒啥作用) - 數值型數組
	@boss_tomb_mapname$[]   	BOSS 墓碑所在的地圖名稱 - 字符型數組
	@boss_tomb_x[]          	BOSS 墓碑所在的 x 坐標 - 數值型數組
	@boss_tomb_y[]          	BOSS 墓碑所在的 y 坐標 - 數值型數組
	
	@boss_tomb_gid[]			BOSS 墓碑的遊戲單位編號 - 數值型數組
								若為 0 則表示還沒生成墳墓
	@boss_tomb_createtime[]		BOSS 墓碑的創建時間 (Unix 時間戳) - 數值型數組
	
	@boss_tomb_respawnsecs[]	BOSS 魔物將在多少秒之後刷新覆活 - 數值型數組
	@boss_tomb_respawntime[]	BOSS 魔物的覆活時間 (Unix 時間戳, 讀取不到則為 -1)
	
	@boss_tomb_killer_name$[]	擊殺 BOSS 魔物的玩家名稱 - 字符型數組
	@boss_tomb_killer_gid[]		擊殺 BOSS 魔物的玩家遊戲單位編號 - 數值型數組
	
	@boss_count					本次查詢返回的記錄數 - 數值型變量

舉例說明:
	getbossinfo();				// 查詢全服地圖的 BOSS 魔物信息
	getbossinfo("this");		// 查詢玩家當前地圖的 BOSS 魔物信息
	getbossinfo("all", 1039);	// 查詢全服地圖中魔物編號為 1039 的 BOSS 魔物信息
	getbossinfo("gef_dun01");	// 查詢 gef_dun01 地圖上的 BOSS 魔物信息
	
注意事項:
	返回值數組變量是 @ 開頭的角色變量.
	若指令在不關聯任何玩家的情況下被執行之後, 可以改用 $@ 變量來承接返回值.
	
	若您使用 $@ 變量來承接返回值內容的話,
	調用 getbossinfo 之後應該立刻使用變量的內容, 因為 $@ 變量是全服共享的, 
	如果調用完成後不立刻使用, 可能里面填充的內容就被其他玩家調用 getbossinfo 替換掉了.
	
	當使用 "this" 指令的時候, 若腳本不關聯任何玩家的話, 那麽必須指定 <角色編號>,
	否則地圖服務器將無法理解 "this" 具體是哪一張地圖.
	
	如果您希望列出一些菜單項讓玩家做選擇的話, 請使用 @ 變量承接.
	因為 @ 變量只保存在玩家角色身上, 不會被服務器其他玩家調用 getbossinfo 指令而覆蓋.
	
	與 getinventorylist 指令一樣, 請避免使用 getarraysize 來計算返回數組的長度,
	而是使用 @boss_count 來作為返回數組中有效內容的最大數量, 否則可能會讀取到部分垃圾數據.
	
	若想在地圖服務器啟動就能獲取所有 BOSS 魔物信息,
	請將 conf/battle/monster.conf 的 dynamic_mobs 設置為 no,
	否則由於動態生成魔物的影響, 必須在 BOSS 所在地圖有玩家前往一次之後,
	才能看到查詢到那張地圖的 BOSS 魔物信息.

--------------------------------------------------------------

*itemlist <物品數組>{,<角色ID>};

生成一個物品選擇框, 返回選中的物品ID, 失敗返回 0 

--------------------------------------------------------------

*skilllist <技能數組>{,<角色ID>};

生成一個物品選擇框, 返回選中的物品ID, 失敗返回 0 

--------------------------------------------------------------

*setnpcicon <NPC的GID>,<BMP圖標組ID>,<標題>;

使用說明:
	使用指令 getnpcid(0) 獲得
	使一個NPC 顯示<BMP圖標>和<標題>, 
	可以使用客戶端自帶的ID圖片 也可以自定義圖片
	添加客戶端自定義圖片路徑: data\texture\蠟歷牢磐其撈膠\group\group_3.bmp
	group_3.bmp 其中 3 為BMP圖標組ID
	
示例:

prontera,150,139,6	script	我是一個NPC	419,{
	end;
Oninit:
	setnpcicon getnpcid(0),3,"npc圖標";
	end;
}

--------------------------------------------------------------
*get2ipinfo {<"IP地址">};

獲得某個IP在線的玩家數以及玩家的角色編號等信息.

如果執行成功的話, 會賦予以下數組在線玩家的信息:

$@sameip_aid[]		使用指定IP在線的玩家賬號編號數組(AccountID)
$@sameip_cid[]		使用指定IP在線的玩家角色編號數組(CharID)
$@sameip_name$[]	使用指定IP在線的玩家角色名數組

$@sameip_amount 目前使用指定IP登錄的玩家個數.

--------------------------------------------------------------
*callitemshop "<商店名字>",<配置>,"<過濾文本>";

配置為10時, 為打開向NPC出售的販賣菜單, 菜單可以使用過濾文本.
過濾為本: "type:物品類型{,物品類型}..;item:物品ID{,物品ID}..;"
例: callitemshop "shoptest",10, "type:6;item:501,502;" 彈出販賣菜單, 菜單只顯示卡片\紅色藥水\赤色藥水, 如果玩家身上有相應物品時才會被顯示...

範例:
-	shop	Test	-1,501:-1

disable_items;
setarray .@test,501,502,503;
callitemshop "Test",2,.@test;
npcshopattach "Test";
end;

配置為2時,出售時，出售清單只會顯示501,502,503,其餘道具不顯示。

--------------------------------------------------------------

*getareamember <團隊類型>,{<範圍>{,<角色ID>}};

獲取指定玩家範圍內同組隊、公會、戰場成員數量及AID

類型：
	PARTY_AREA:  範圍內的隊伍成員
	GUILD_AREA:  範圍內的公會成員
	BG_AREA:     範圍內的戰場成員

返回值:
	成員數數量

返回變量:
	@member_aid 儲存成員AID

--------------------------------------------------------------

*getmapmember <團隊類型>,"<地圖名>",<團隊ID>;

獲取地圖內指定組隊、公會、戰場成員數量及AID

類型：
	PARTY_AREA:  範圍內的隊伍成員
	GUILD_AREA:  範圍內的公會成員
	BG_AREA:     範圍內的戰場成員

返回值:
	成員數數量

返回變量:
	$@member_aid 儲存成員AID
	
--------------------------------------------------------------

*isequipped2(<物品ID>{,<物品ID>{,<物品ID>{,<物品ID>}}})

用法同 isequipped 可以支持任何物品ID, 主要用於拓展附魔道具. 

返回值:
	返回數量

--------------------------------------------------------------